# ubuntu使用

## 基本命令行语法

在 Ubuntu 中使用命令行是与操作系统交互的一个强大方式。命令行界面（CLI）允许用户通过键入特定命令来执行操作，从基本的文件操作到系统管理和软件安装等。以下是一些 Ubuntu 命令行的基本用法：

### 打开终端
- 在 Ubuntu 中，可以通过快捷键 `Ctrl + Alt + T` 打开终端，或在应用菜单中搜索并打开“Terminal”。

### 基本命令
1. **ls**：列出当前目录下的文件和文件夹。
   - `ls -l`：以详细列表格式显示文件和文件夹。

2. **cd**：更改当前工作目录。
   - `cd /path/to/directory`：进入指定目录。

3. **pwd**：显示当前工作目录的完整路径。

4. **mkdir**：创建新目录。
   - `mkdir new_directory`：在当前目录下创建一个新目录。

5. **touch**：创建一个新的空文件。
   - `touch filename`：创建一个名为 `filename` 的新文件。

6. **rm**：删除文件或目录。
   - `rm filename`：删除一个文件。
   - `rm -r directory`：递归删除一个目录及其内容。

7. **cp**：复制文件或目录。
   - `cp source destination`：将文件从源路径复制到目标路径。

8. **mv**：移动或重命名文件或目录。
   - `mv source destination`：移动或重命名。

9. **cat**：查看或连接文件的内容。
   - `cat filename`：显示文件内容。

10. **nano**、**vim**：文本编辑器。
    - `nano filename` 或 `vim filename`：在 Nano 或 Vim 编辑器中打开文件。

### 系统管理命令
1. **sudo**：以超级用户权限执行命令。
   - `sudo apt update`：以管理员权限更新软件包列表。

2. **apt-get / apt**：软件包管理工具。
   - `sudo apt-get install package_name`：安装软件包。
   - `sudo apt update`：更新软件包列表。
   - `sudo apt upgrade`：升级所有可升级的软件包。

3. **chmod**：更改文件或目录的权限。
   - `chmod +x filename`：使文件可执行。

4. **chown**：更改文件或目录的所有者。
   - `sudo chown user:group filename`：更改文件的所有者和组。

5. **ps**、**top**：查看正在运行的进程。
   - `ps aux` 或 `top`：显示当前运行的进程。

6. **df**、**du**：磁盘使用情况。
   - `df -h`：显示磁盘空间使用情况。
   - `du -sh directory`：显示目录的大小。

### 获取帮助

- 在命令后加上 `--help` 或使用 `man` 命令可以获得关于该命令的帮助信息。
   - 例如：`ls --help` 或 `man ls`

使用命令行时，最重要的是理解你正在执行的命令的作用，特别是在使用具有系统更改能力的命令（如 `rm`、`sudo`）时。随着实践的增加，你将更加熟练地使用这些命令。

## 管道符“|”

管道符（`|`）是 Linux 和 Unix 操作系统中非常强大的一个特性，它允许你将一个命令的输出直接作为另一个命令的输入。这使得不同命令之间可以灵活组合，执行复杂的操作。以下是对管道符的基本用法的详细解释：

### 基本概念
- **管道符** `|` 用于连接两个或多个命令。
- 当使用管道时，第一个命令的标准输出（stdout）会被传递到第二个命令的标准输入（stdin）。

### 基本用法
1. **文本处理**:
   - 将文本处理命令（如 `grep`, `sort`, `uniq`）结合起来使用。
   - 示例：从一系列文件中找出包含特定文本的行：
     ```
     cat files.txt | grep "search_text"
     ```

2. **排序和去重**:
   - 用 `sort` 对输出进行排序，用 `uniq` 过滤重复行。
   - 示例：对文件内容排序并去除重复行：
     ```
     cat files.txt | sort | uniq
     ```

3. **统计信息**:
   - 结合 `wc` 命令来统计行、单词或字符的数量。
   - 示例：统计文件中单词的数量：
     ```
     cat files.txt | wc -w
     ```

4. **列数据处理**:
   - 使用 `awk` 或 `cut` 处理复杂的列数据。
   - 示例：打印进程列表中的第一列（PID）：
     ```
     ps aux | awk '{print $1}'
     ```

5. **组合多个命令**:
   - 将多个命令通过管道符连接起来，形成一条命令链。
   - 示例：搜索文本，排序并取前五行：
     ```
     grep "search_text" files.txt | sort | head -n 5
     ```

### 高级用法
- **多个管道**：
  - 可以将多个管道符和命令组合在一起，形成一个复杂的命令链。
  - 示例：查找文件，按行数排序并获取最长的5个文件：
    ```
    find . -type f -exec wc -l {} \; | sort -n | tail -n 5
    ```

### 注意事项
- 确保每个命令能够正确处理前一个命令的输出。
- 管道中的命令是同时执行的，而不是按顺序一个接一个执行。
- 管道仅处理标准输出，不处理标准错误输出（stderr）。

管道符的使用极大地提高了命令行的效率和灵活性，是 Linux 和 Unix 用户日常操作中不可或缺的一部分。通过合理使用管道，可以实现复杂的文本处理和数据分析功能。

## grep

`grep` 是一种在文本中搜索指定模式的强大命令行工具，广泛用于 Unix 和 Linux 系统。它可以搜索一个或多个文件中的文本，并打印出匹配指定模式的行。以下是 `grep` 基本用法的详细解释：

### 基本语法
- 命令格式：`grep [options] pattern [file...]`
- `pattern` 是你要搜索的文本。
- `[file...]` 是要搜索的文件。如果不指定文件，`grep` 会从标准输入读取数据。

### 搜索文本
- 在文件中搜索文本：
  - `grep 'text' filename`
  - 这会在 `filename` 中搜索字符串 `text` 并输出包含该字符串的行。

### 使用正则表达式
- `grep` 支持正则表达式，这使得它能够进行更复杂的匹配：
  - `grep '^[A-Z]' filename`
  - 这会在文件中搜索以大写字母开头的行。

### 不区分大小写的搜索
- `-i` 选项使搜索不区分大小写：
  - `grep -i 'text' filename`
  - 无论是 `text`、`Text`、`TEXT` 还是其他任何大小写变体，都会被匹配。

### 只输出匹配的部分
- `-o` 选项只输出匹配的文本部分，而不是整行：
  - `grep -o 'text' filename`

### 输出行号
- `-n` 选项在输出中包含行号：
  - `grep -n 'text' filename`
  - 这会显示匹配行及其在文件中的行号。

### 统计匹配的数量
- `-c` 选项用于统计匹配的行数：
  - `grep -c 'text' filename`

### 反向匹配
- `-v` 选项用于输出不匹配模式的行：
  - `grep -v 'text' filename`

### 从多个文件中搜索
- `grep` 可以同时搜索多个文件：
  - `grep 'text' filename1 filename2`

### 搜索目录中的所有文件
- `-r` 或 `-R` 选项用于递归地在目录中搜索所有文件：
  - `grep -r 'text' /path/to/directory`

### 正则表达式的扩展功能
- `-E` 选项允许使用扩展的正则表达式，这意味着你可以使用更复杂的模式：
  - `grep -E '[0-9]+' filename`
  - 搜索包含一个或多个数字的行。

### 使用管道与其他命令结合

- `grep` 经常与其他命令结合使用，特别是与管道符号 `|`：
  - `cat filename | grep 'text'`
  - 这会显示文件中包含 `text` 的行。

`grep` 是文本处理中非常有用的工具，特别是当处理大型文件或复杂的搜索时。通过灵活运用 `grep` 的选项和正则表达式，你可以实现各种文本搜索和数据提取任务。

## ubuntu文件系统

Ubuntu的文件系统遵循Unix和Linux的标准文件系统层次结构（Filesystem Hierarchy Standard, FHS），它定义了操作系统中文件和目录应该如何组织。这种结构不仅为Ubuntu系统，而且为大多数Linux发行版提供了一致的框架。以下是Ubuntu文件系统的关键组成部分的详细解释：

#### 根目录 (`/`)

这是文件系统的顶层。所有其他目录都从这里开始。它包含了系统的主要目录。

##### `/bin`

包含系统启动和运行所必需的二进制程序（可执行文件）。这些命令对所有用户都是必需的，如 `ls`, `cp`, `mv`, `rm` 等。

##### `/boot`

包含启动Linux系统所需的文件，如内核 (`vmlinuz`)，引导加载程序 (如 GRUB) 的配置文件等。

##### `/dev`

包含设备文件。Linux将硬件设备视为文件，这些设备文件通常位于此目录。

##### `/etc`

存储系统配置文件。这些文件由系统管理员编辑，用于配置系统的行为。

##### `/home`

存储用户的个人文件夹。每个用户在 `/home` 下有一个与其用户名相对应的目录。

##### `/lib`

包含系统启动和 `/bin` 与 `/sbin` 目录中的程序运行所必需的共享库文件和内核模块。

##### `/media`

用于挂载可移动媒体设备，如CD-ROM驱动器、USB闪存驱动器等。

##### `/mnt`

传统上用于临时挂载文件系统。

##### `/opt`

用于安装“可选”的软件，通常是那些不属于操作系统默认组件的第三方应用程序。

##### `/proc`

这是一个虚拟文件系统，包含了系统和进程信息的接口。例如，`/proc/cpuinfo` 文件包含CPU信息。

##### `/root`

系统管理员（root用户）的家目录。

##### `/sbin`

存储系统管理和维护所需的二进制程序，通常只有root用户才能运行这些程序。

##### `/srv`

包含一些为系统上的服务提供数据的目录。

##### `/sys`

这也是一个虚拟文件系统，提供了内核及其连接的设备的接口。

##### `/tmp`

用于存储临时文件。系统重启时，这个目录下的文件通常会被删除。

##### `/usr`

包含用户的大多数应用程序和文件。它包括四个主要目录：`/usr/bin`（大多数用户命令）、`/usr/sbin`（一些管理员命令）、`/usr/lib`（库文件），和 `/usr/local`（本地安装的软件）。

##### `/var`

包含经常变化的文件，如日志、数据库、邮件等。

##### `/run`

一个临时文件系统，存储自系统启动以来的信息。在重新启动时会清空。

这种文件系统结构提供了一种标准化的方法来组织不同类型的文件和目录，使得用户和程序能够知道在哪里可以找到或存放文件和数据。这对于系统的维护、管理和使用都是非常重要的。

## apt-get

`apt-get` 是 Debian 及其衍生版（如 Ubuntu）操作系统中的命令行工具，用于处理软件包的安装、更新、升级和清理等操作。以下是 `apt-get` 的一些基本用法：

1. **更新软件包列表**:
   - `sudo apt-get update`
   - 这个命令会从配置的源（repositories）中下载软件包的最新列表，确保后续安装或升级软件时，能获取到最新版本。

2. **升级所有软件包**:
   - `sudo apt-get upgrade`
   - 升级所有已安装的软件包到最新版本。这个命令不会安装新的软件或自动删除不再需要的软件包。

3. **完全升级系统**:
   - `sudo apt-get dist-upgrade`
   - 与 `upgrade` 类似，但它会智能处理依赖关系变化，可能安装新的软件包或删除不再需要的软件包。

4. **安装软件包**:
   - `sudo apt-get install [package-name]`
   - 安装指定的软件包。如果已安装，会尝试升级到最新版本。

5. **卸载软件包**:
   - `sudo apt-get remove [package-name]`
   - 删除指定的软件包，但保留配置文件。

6. **彻底卸载软件包及其配置文件**:
   - `sudo apt-get purge [package-name]`
   - 不仅删除软件包，还删除其配置文件。

7. **自动删除不再需要的依赖包**:
   - `sudo apt-get autoremove`
   - 自动删除那些被安装了的软件包的依赖包，但现在不再需要的包。

8. **清除下载的软件包归档文件**:
   - `sudo apt-get clean`
   - 清除本地下载的软件包归档文件，释放磁盘空间。

9. **查看软件包信息**:
   - `apt-get show [package-name]`
   - 显示指定软件包的详细信息，如版本、依赖关系等。

`apt-get` 是一种非常强大的工具，用于维护系统的软件状态，特别适合喜欢通过命令行管理系统的用户。使用 `apt-get` 命令时通常需要管理员权限，因此在命令前面通常会添加 `sudo`。

>使用`apt-get`（或其简化版本`apt`）安装软件包时，该软件包的一些组件通常会自动添加到环境变量中，具体表现在以下几个方面：
>
>1. **可执行文件路径**：大多数通过`apt-get`安装的软件包会将其可执行文件放置在标准的系统路径中，如`/usr/bin/`或`/usr/local/bin/`。这些目录通常已经包含在`PATH`环境变量中，因此安装后，你可以直接通过终端运行这些程序，而无需更改`PATH`。
>
>2. **库文件**：如果软件包包含库文件，这些文件通常会被放置在系统的库目录中，如`/usr/lib/`。系统已经配置了这些路径，以便在运行程序时自动查找这些库。
>
>3. **配置文件和其他资源**：许多软件包还包含配置文件、文档或其他资源，这些文件通常存放在`/etc/`、`/usr/share/`等目录中。这些位置通常是标准的，由软件包维护者和操作系统规范决定。
>
>然而，有些情况下，软件包可能需要特定的环境变量设置才能正确运行，或者它们可能带有脚本来更新环境变量。这种情况下，可能需要手动配置或者遵循安装后提供的指示来更新环境变量。
>
>总的来说，`apt-get`安装的软件包通常不需要手动添加环境变量，因为它们被安装到系统已经识别的标准路径中。如果需要特定的环境设置，软件包的文档通常会提供必要的说明。

## apt

`apt`（Advanced Package Tool）是 Debian 及其衍生版（如 Ubuntu）操作系统中的命令行工具，用于管理软件包。它提供了一种简单易用的方式来安装、升级、配置和移除软件包。以下是 `apt` 的一些基本用法：

1. **更新软件包列表**:
   - `sudo apt update`
   - 这个命令会同步包索引源列表，确保了在安装或升级软件包时，系统能获取到最新的软件包信息。

2. **升级软件包**:
   - `sudo apt upgrade`
   - 它会将系统上已安装的软件包升级到最新版本。此操作不会安装新软件包或删除已安装的软件包。

3. **完全升级系统**:
   - `sudo apt full-upgrade`
   - 类似于 `apt-get dist-upgrade`，它在升级包的同时解决依赖关系，可能会安装新的软件包或删除现有的软件包以满足依赖关系。

4. **安装软件包**:
   - `sudo apt install [package-name]`
   - 用于安装一个或多个指定的软件包。如果软件包已安装，则会更新到最新版本。

5. **删除软件包**:
   - `sudo apt remove [package-name]`
   - 用于从系统中删除指定的软件包，但它不会删除软件包的配置文件。

6. **彻底删除软件包及配置文件**:
   - `sudo apt purge [package-name]`
   - 除了删除软件包外，还会删除其配置文件。

7. **自动删除不再需要的软件包**:
   - `sudo apt autoremove`
   - 自动删除不再需要的软件包，这些通常是被作为其他软件包的依赖而安装的，但现在不再需要的软件包。

8. **清除本地下载的软件包归档文件**:
   - `sudo apt clean`
   - 清除已下载的软件包文件，释放磁盘空间。

9. **搜索软件包**:
   - `apt search [keyword]`
   - 搜索包含指定关键字的软件包。

10. **显示软件包信息**:
    - `apt show [package-name]`
    - 显示指定软件包的详细信息，包括版本、依赖关系等。

`apt` 提供了一个比 `apt-get` 和 `apt-cache` 更为人性化的接口，使软件包的管理变得更加简单直观。在使用 `apt` 命令时，通常需要管理员权限，因此在大多数命令前都需要加上 `sudo`。

## .deb和dpkg

### .deb

`.deb` 文件是 Debian Linux 及其衍生系统（如 Ubuntu）中使用的软件包格式。这种格式用于分发和安装软件。下面是对 `.deb` 文件的更详细解释：

#### 结构和内容

`.deb` 文件实际上是一个压缩的存档文件，它包含了安装软件所需的所有文件和信息。一个标准的 `.deb` 文件通常包括以下部分：

1. **二进制文件**：这是软件的可执行文件，通常存放在 `/usr/bin` 或 `/usr/local/bin` 等目录。

2. **配置文件**：软件的配置文件，通常放在 `/etc` 目录下。

3. **文档和手册**：包括使用说明、许可证信息等，通常放在 `/usr/share/doc` 或 `/usr/share/man` 目录。

4. **库文件**：如果软件依赖特定的库文件，这些文件也会包含在 `.deb` 包中。

5. **元数据**：`.deb` 文件还包含一些元数据，如软件的名称、版本、依赖关系、包维护者的信息等。这些信息对于包管理系统处理和解决依赖关系非常重要。

#### 安装过程

当你安装一个 `.deb` 文件时，Debian的包管理系统（如 `dpkg` 或 APT）会解压这个文件，将文件放置到系统的相应位置，并解决软件的依赖问题。安装过程通常包括以下步骤：

1. **解压文件**：包管理器首先解压 `.deb` 文件。

2. **执行预配置脚本**：如果存在，预配置脚本会在安装过程中的早期运行。

3. **复制文件**：软件的文件会被复制到系统的相应目录。

4. **配置软件**：执行配置脚本来完成安装，包括设置权限、配置系统服务等。

5. **执行后安装脚本**：最后，如果存在，会执行一个后安装脚本来完成安装过程。

#### 使用和管理

在基于 Debian 的系统中，`.deb` 文件可以通过命令行工具 `dpkg`、`apt-get` 或图形界面工具（如 Ubuntu Software Center）来管理。这些工具提供安装、升级、查询和移除软件包的功能。

#### 总结

`.deb` 文件是 Debian 系统中软件分发和安装的基础。它使得软件安装过程标准化、简化，并帮助管理系统中的软件。由于 `.deb` 文件包含了软件的所有必要组件和详细的元数据，它们对于维护系统的整体一致性和稳定性至关重要。

### dpkg

`dpkg` 是 Debian Linux 系统及其衍生系统（如 Ubuntu）中的一个基础包管理工具。它用于安装、构建、移除和管理 `.deb` 软件包，但它不解决软件包的依赖问题。以下是对 `dpkg` 的更详细解释：

#### 基本功能

1. **安装软件包**：`dpkg` 可以安装本地的 `.deb` 文件。例如，使用 `dpkg -i package.deb` 命令可以安装名为 `package.deb` 的软件包。

2. **移除软件包**：它可以移除已安装的软件包，但通常保留配置文件。使用 `dpkg -r package` 移除软件包，其中 `package` 是软件包的名称。

3. **清除软件包**：除了移除软件包，`dpkg` 还可以清除软件包的配置文件。使用 `dpkg -P package` 完全清除软件包。

4. **列出软件包**：`dpkg -l` 命令可用于列出系统上安装的所有软件包。

5. **查询软件包信息**：`dpkg -s package` 命令用于查询指定软件包的信息。

6. **配置软件包**：如果软件包未完全配置，可以使用 `dpkg --configure package` 命令来配置它。

#### 工作机制

`dpkg` 通过读取和解压 `.deb` 文件中的内容，将文件复制到系统的相应位置来安装软件包。它还处理软件包的预配置和后配置脚本，确保软件包正确安装。

#### 不处理依赖关系

与 APT 等高级包管理工具不同，`dpkg` 本身不自动处理软件包的依赖问题。如果一个 `.deb` 文件依赖于尚未安装的包，`dpkg` 会报错并停止安装过程。因此，当处理复杂的依赖关系时，用户通常会使用 APT 这样的工具，它们可以自动解决依赖并调用 `dpkg` 来实际安装包。

#### 配置文件和数据库

- `dpkg` 维护一个本地数据库，存储关于系统上所有已安装软件包的信息。这个数据库位于 `/var/lib/dpkg` 目录。

- 软件包的配置文件通常存储在 `/etc` 目录下。

#### 总结

`dpkg` 是 Debian 系统中的一个重要组成部分，它为软件包的安装和管理提供了基础功能。尽管它不处理依赖问题，但它在 Debian 包管理体系中仍然扮演着核心角色。对于日常软件管理，用户更倾向于使用如 `apt` 或 `apt-get` 这样的高级工具，因为它们提供了更完整的解决方案，包括依赖处理和远程仓库支持。

>`.deb` 文件是Debian软件包的格式，用于Debian及其衍生的Linux发行版（如Ubuntu）上。这些软件包包含了软件的文件和安装信息，使得软件安装和管理变得简便。以下是如何在基于Debian的系统上操作 `.deb` 软件包的基本步骤：
>
>### 安装 `.deb` 软件包
>
>1. **使用dpkg**：
>   - `dpkg` 是Debian的底层包管理工具。要使用它安装 `.deb` 包，首先打开终端，然后使用以下命令：
>     ```bash
>     sudo dpkg -i /path/to/package.deb
>     ```
>   - 这里 `/path/to/package.deb` 是 `.deb` 文件的路径。
>
>2. **使用APT**：
>   - 你也可以使用APT（高级包管理工具）来安装 `.deb` 包。APT会自动处理依赖问题（如果有的话）：
>     ```bash
>     sudo apt install ./path/to/package.deb
>     ```
>   - 请注意，从APT 1.1开始，你可以直接使用 `apt` 来安装本地 `.deb` 文件。
>
>3. **图形界面工具**：
>   - 在许多基于Debian的发行版中，你可以双击 `.deb` 文件来打开一个图形界面的安装程序，如GDebi或Ubuntu的软件中心。
>
>### 卸载 `.deb` 软件包
>
>1. **使用dpkg**：
>   - 要卸载一个 `.deb` 软件包，你需要知道软件包的名称。使用dpkg卸载软件包的命令如下：
>     ```bash
>     sudo dpkg -r package_name
>     ```
>   - 这里的 `package_name` 是软件包的名称，而不是 `.deb` 文件的名称。
>
>2. **使用APT**：
>   - 同样，你也可以使用 `apt` 来卸载软件包：
>     ```bash
>     sudo apt remove package_name
>     ```
>
>### 查询包信息
>
>- **查看已安装的包**：
>  - 要查看系统上已安装的包，可以使用：
>    ```bash
>    dpkg -l
>    ```
>  - 这将列出所有已安装的包。
>
>- **查看包的详细信息**：
>  - 要查看特定包的详细信息（例如，`.deb` 文件中包含的文件），可以使用：
>    ```bash
>    dpkg -L package_name
>    ```
>  - 或者，要查看 `.deb` 文件的内容而不安装它：
>    ```bash
>    dpkg -c /path/to/package.deb
>    ```
>
>### 解决依赖问题
>
>- 有时安装 `.deb` 包时可能会遇到依赖性问题。在这种情况下，可以尝试使用 `apt-get -f install` 命令来修复依赖：
>  ```bash
>  sudo apt-get -f install
>  ```
>- 这个命令将尝试自动安装任何缺失的依赖项。
>
>这些是处理 `.deb` 软件包的基本操作。在使用时，建议了解你正在安装的软件包的来源和内容，以确保系统的安全和稳定性。

## 修改文件权限

在 Ubuntu（或任何基于 Linux 的操作系统）中修改文件权限是一个常见的操作，可以通过 `chmod` 命令来实现。以下是详细解释如何在 Ubuntu 下修改文件权限：

### 基本概念

- **权限类型**：
  - **读 (Read)**：用 `r` 表示，允许读取文件内容。
  - **写 (Write)**：用 `w` 表示，允许修改文件内容。
  - **执行 (Execute)**：用 `x` 表示，允许运行文件作为程序。

- **用户类别**：
  - **文件所有者 (Owner)**：通常是创建文件的用户。
  - **群组 (Group)**：文件所属的用户组。
  - **其他用户 (Others)**：不是文件所有者或群组成员的其他用户。

### chmod 命令

- **命令格式**：`chmod [options] mode file`
- **mode**：指定权限设置，可以用数字或符号表示。

### 使用数字修改权限

- 权限数字对应：
  - 读 (r) = 4
  - 写 (w) = 2
  - 执行 (x) = 1
- 组合这些数字来设置相应的权限。例如：
  - `chmod 755 filename`：设置文件所有者具有读写执行权限（7 = 4+2+1），而群组和其他用户具有读和执行权限（5 = 4+1）。

### 使用符号修改权限

- `u`、`g` 和 `o` 分别代表文件所有者、群组和其他用户。
- 示例：
  - `chmod u+x filename`：给文件所有者添加执行权限。
  - `chmod g-w filename`：移除群组的写权限。
  - `chmod o=r filename`：设置其他用户仅具有读权限。

### 递归修改权限

- 使用 `-R` 选项可以递归地修改目录及其所有子目录和文件的权限。例如：
  - `chmod -R 755 directory`：将指定目录及其所有子目录和文件的权限设置为 755。

### 注意事项

- 修改文件或目录权限可能会影响系统安全和功能。在更改关键文件或目录的权限之前，确保您了解其后果。
- 仅当您是文件的所有者或超级用户（如使用 `sudo`）时，才能更改文件的权限。

通过这些基本概念和示例，您可以在 Ubuntu 上灵活地修改文件和目录的权限以满足不同的需求。记住，在操作系统层面，正确的权限设置是保护数据安全和系统稳定性的关键。



## 从源码编译安装软件

>在Ubuntu 20.04上通过源码编译安装软件的原理涉及以下几个主要步骤和概念：
>
>1. **源代码**：软件通常以源代码的形式进行分发。源代码是程序的人类可读形式，通常以文本文件的形式包含了程序的源代码文件、头文件、配置文件等。编译是将源代码翻译成计算机可以执行的二进制文件的过程。
>
>2. **编译器**：编译器是一种将源代码转化为可执行代码的工具。在Ubuntu中，常见的编译器是GNU Compiler Collection (GCC)。编译器会根据源代码文件中的指令和语法规则来生成二进制可执行文件。
>
>3. **构建系统**：构建系统是用于自动化和管理编译过程的工具。在大多数情况下，软件的源代码附带了一个构建系统，它通常包括一个配置脚本（例如`configure`脚本）和一个Makefile。配置脚本负责检查系统环境、依赖项和设置编译选项，而Makefile则定义了编译过程中的规则和依赖关系。
>
>4. **依赖项**：软件通常依赖于其他库和组件。在编译软件之前，你需要确保系统上已经安装了这些依赖项，以便在编译过程中能够链接到它们。如果依赖项不满足，编译过程可能会失败。
>
>5. **配置**：在编译软件之前，你需要运行配置脚本来检查系统环境并设置编译选项。这个脚本会根据系统的不同自动检测依赖项和系统库，并生成一个Makefile，该Makefile包含了编译软件所需的所有规则和依赖关系。
>
>6. **编译**：一旦配置完成，你可以运行`make`命令来执行实际的编译过程。`make`将根据Makefile中的规则编译源代码，并生成可执行文件或库文件。
>
>7. **安装**：编译完成后，你可以使用`sudo make install`命令将编译好的文件复制到系统的标准位置，以便其他程序可以访问它们。安装通常包括将可执行文件、库文件、头文件和其他必要的资源复制到系统目录中。
>
>8. **清理**：为了节省磁盘空间，你可以使用`make clean`命令来删除编译过程中生成的临时文件和中间文件。这不会影响已安装的软件。
>
>总的来说，源码编译软件的原理涉及将人类可读的源代码转化为计算机可执行的二进制文件的过程，通过配置脚本和构建系统来管理依赖项、编译选项和编译过程，最终安装软件并将其集成到系统中。这种方法通常用于需要定制编译选项、最新版本或不在软件仓库中的软件。

从源代码编译软件是 Linux 系统上一种常见的软件安装方法，尤其是当软件包不在系统的包管理器中时。编译源代码允许用户在特定硬件和操作系统上对软件进行优化，并使得用户可以根据自己的需要对软件进行定制。以下是详细的步骤：

### 1. 安装编译工具和依赖
首先，确保你的系统安装了编译源码所需的工具，如编译器（gcc/g++）、make 工具和其他依赖库。在 Debian 或 Ubuntu 系统中，可以使用以下命令安装基本的编译工具：
```bash
sudo apt-get install build-essential
```
对于软件特定的依赖库，通常可以在软件的文档中找到所需的包列表。

### 2. 下载源码

源代码通常以 tarball（如 `.tar.gz` 或 `.tar.bz2`）的形式分发。你可以从项目的官网或源代码仓库（如 GitHub）下载源码压缩包。也可以使用 `wget` 或 `curl` 命令从命令行下载：
```bash
wget [URL]
```
或者
```bash
curl -O [URL]
```

### 3. 解压源码
下载后，需要解压缩源码。通常使用 `tar` 命令：
```bash
tar xzf sourcecode.tar.gz
```
或者
```bash
tar xjf sourcecode.tar.bz2
```

### 4. 配置构建环境
进入解压后的源码目录：
```bash
cd sourcecode
```
然后运行 `./configure` 脚本来配置构建环境。这个脚本会检查你的系统是否有编译软件所需的所有依赖，并根据系统环境创建适合的 Makefile。有时你可能需要指定选项，例如安装目录：
```bash
./configure --prefix=/usr/local
```

### 5. 编译软件
一旦配置完成，使用 `make` 命令编译软件：
```bash
make
```
这可能需要一些时间，取决于软件的大小和复杂性。

### 6. 安装软件

编译完成后，使用以下命令安装软件：
```bash
sudo make install
```
这会将编译好的文件安装到系统的合适位置。

### 7. 清理编译文件（可选）
安装完成后，可以运行以下命令清理临时编译文件：
```bash
make clean
```

### 注意事项
- 从源代码编译软件通常比使用包管理器安装软件更复杂，可能会遇到各种依赖问题和编译错误。
- 通常，只有在包管理器中没有所需软件或你需要特定版本或定制化配置时，才需要从源码编译。
- 编译安装的软件不会被系统的包管理器管理，这意味着更新和卸载可能需要手动进行。

从源代码编译软件是 Linux 用户的一项重要技能，它提供了灵活性和控制，但也带来了额外的复杂性。对于初学者来说，理解这个过程可能需要一些时间和实践。

## makefile文件

`Makefile`是一种文本文件，用于定义如何构建和编译一个项目中的源代码文件。它通常与`make`工具一起使用，用于自动化和管理代码编译和构建的过程。`make`工具会根据`Makefile`文件中的规则和依赖关系，确定哪些文件需要重新编译，以及如何编译它们。

以下是`Makefile`的主要组成部分和概念：

1. **目标（Target）**：目标是`Makefile`中的命名标识符，代表一个要构建的文件或任务。目标可以是可执行文件、库文件、中间文件或任何其他构建任务。例如：

   ```make
   my_program: main.c utils.c
       gcc -o my_program main.c utils.c
   ```

   在上面的示例中，`my_program`是一个目标，代表了一个可执行文件。该目标依赖于`main.c`和`utils.c`这两个源代码文件。

2. **依赖关系（Dependencies）**：依赖关系指定了一个目标所依赖的文件或其他目标。当目标的依赖项发生变化时，`make`会根据这些依赖关系决定是否需要重新构建目标。在上面的示例中，`my_program`的依赖关系是`main.c`和`utils.c`。

3. **规则（Rules）**：规则定义了如何从依赖项构建目标。它包含了一个或多个命令，用于执行编译、链接或其他构建操作。规则的语法通常是：

   ```make
   target: dependencies
       command1
       command2
       ...
   ```

   在上面的示例中，规则指定了如何从`main.c`和`utils.c`构建`my_program`，并使用`gcc`编译器执行命令来生成可执行文件。

4. **变量（Variables）**：`Makefile`中可以定义变量，用于存储重复使用的值，例如编译器的名称、编译选项等。这样可以使`Makefile`更加可维护和可配置。

   ```make
   CC = gcc
   CFLAGS = -Wall -O2

   my_program: main.c utils.c
       $(CC) $(CFLAGS) -o my_program main.c utils.c
   ```

   在上面的示例中，`CC`和`CFLAGS`是两个变量，它们用于存储编译器和编译选项。

5. **默认目标（Default Target）**：`Makefile`可以指定一个默认的目标，当你运行`make`命令而没有指定目标时，`make`将构建默认目标。默认目标通常是项目中最重要的目标。

   ```make
   all: my_program
   
   my_program: main.c utils.c
       gcc -o my_program main.c utils.c
   ```

   在上面的示例中，`all`是默认目标，它依赖于`my_program`。

通过使用`Makefile`，开发人员可以轻松管理项目的构建过程，确保只有在必要的情况下才会重新编译文件，以提高效率。`make`工具会自动检测文件的时间戳以确定哪些文件需要更新，从而避免了手动执行编译命令的繁琐工作。因此，`Makefile`是构建和编译软件项目的重要工具，尤其在大型项目中更为有用。

## profile文件

在Linux和Unix系统中，包括Ubuntu在内的许多发行版，`.profile`文件是一个非常重要的配置文件。这个文件位于用户的主目录下，通常用于设置用户级的环境变量和启动脚本。下面是对`.profile`文件的详细解释：

### 位置
- `.profile`文件通常位于用户的主目录中，例如`/home/username/.profile`。
- 它是一个隐藏文件，因为其名称以点（`.`）开头。

### 作用
- **环境变量设置**：`.profile`用于定义用户级的环境变量。这些变量可以是路径设置（如`PATH`环境变量），或者其他用于自定义用户环境的变量。
- **自动执行脚本**：登录时，shell会自动执行`.profile`中的命令。这可以用来运行脚本，设置别名，定义函数等。

### 与其他文件的关系

- Ubuntu和其他基于Bash的系统还使用其他文件如`.bashrc`和`.bash_profile`来设置环境变量和执行命令。
- `.profile`和`.bash_profile`在登录shell（如通过图形界面登录）时执行，而`.bashrc`通常在非登录交互式shell（如打开一个新的终端窗口）中执行。

### 编辑注意事项
- 编辑`.profile`文件时需要小心，因为错误的设置可能导致登录问题或者其他环境问题。
- 通常，如果你不确定自己在做什么，最好不要修改这个文件。
- 如果需要修改，建议先备份原始文件。

### 示例
`.profile`文件可能包含像这样的内容：

```bash
# 设置PATH环境变量
PATH="$HOME/bin:$PATH"

# 自定义别名
alias ll='ls -la'

# 运行自定义脚本
if [ -f "$HOME/.my_custom_script" ]; then
    . "$HOME/.my_custom_script"
fi
```

### 修复问题

如果`.profile`文件的错误配置导致了登录问题，通常的修复方法是恢复或删除导致问题的部分，或者完全还原到默认设置。

综上所述，`.profile`文件是个强大但需要谨慎处理的工具，它对用户的登录环境和shell行为有着深远的影响。

## 环境变量及更改环境变量

环境变量是在操作系统中用于存储系统级或用户级信息的变量，它们通常用于存储诸如文件路径、系统配置、用户设置等信息。在Ubuntu 20.04和其他类Unix系统中，环境变量扮演着重要的角色。

### 环境变量的作用
1. **存储配置信息**：环境变量可以包含关于系统如何运行的信息，例如，哪里可以找到某个程序的执行文件。
2. **控制程序行为**：许多程序会根据特定的环境变量来调整其行为。例如，`PATH`环境变量告诉shell在哪些目录中查找可执行文件。
3. **用户会话设置**：环境变量可以用来保存用户的偏好设置，如语言设置、时区等。

### 常见的环境变量
- `PATH`：定义了shell搜索可执行文件的目录。
- `HOME`：当前用户的主目录。
- `LANG`：定义了系统语言和地区设置。
- `USER`：当前登录的用户名。

### 如何在Ubuntu 20.04中添加或更改环境变量

1. **临时更改**：
   - 在命令行中，你可以使用`export`命令来设置环境变量，这将仅对当前会话有效。
   - 例如，要临时添加一个目录到`PATH`，可以使用：
     ```bash
     export PATH=$PATH:/my/new/path
     ```
   - 这种更改在关闭终端或结束会话时会丢失。

2. **永久更改**：
   - 要永久更改环境变量，你需要编辑用户的`.profile`、`.bashrc`或者全系统的环境设置。
   - 对于个别用户，编辑`~/.profile`或`~/.bashrc`：
     - 打开文件：`nano ~/.profile`（或者使用你喜欢的文本编辑器）。
     - 添加相同的`export`语句：`export PATH=$PATH:/my/new/path`。
     - 保存并关闭文件。
     - 更改将在下次登录时生效。
   - 对于所有用户，编辑`/etc/environment`或`/etc/profile`：
     - 需要使用超级用户权限：`sudo nano /etc/environment`。
     - 在这个文件中添加新的环境变量或更改现有的。
     - 保存并关闭文件。
     - 更改将在重启后或新会话中生效。

3. **应用更改**：
   - 对于`.profile`或`.bashrc`的更改，可以通过注销然后重新登录或者使用`source ~/.profile`来应用更改。
   - 对于全系统的更改，通常需要重启系统。

### 注意事项
- 编辑这些文件时要小心，因为错误的设置可能会导致系统问题。
- 使用命令行编辑文件时，确保你熟悉所用的文本编辑器。
- 对于系统级的更改，最好有一定的系统管理经验。

环境变量是一个强大的工具，可以帮助你自定义和优化你的系统环境，但它们需要谨慎使用，特别是在做系统级的更改时。

## 创建桌面图标

```bash
sudo vim ~/.local/share/applications/clash.desktop # 编辑一个文件
# 写入如下内容
[Desktop Entry]
Name=Clash Fow Windows
Exec=/home/user/.local/bin/cfw
Icon=/home/user/.local/bin/cfw
Type=Application
StartupNotify=true
然后添加可执行权限：
sudo chmod +x ~/.local/share/applications/clash.desktop
```

这段代码是在 Linux 系统（特别是使用 GNOME 桌面环境的系统，如 Ubuntu）中创建一个新的桌面图标（快捷方式）的步骤。下面是对这些命令的解释以及如何创建桌面图标的步骤和模板。

1. `sudo vim ~/.local/share/applications/clash.desktop`：这个命令使用 `vim` 编辑器（一种文本编辑器）打开（或创建）位于 `~/.local/share/applications/` 目录下的 `clash.desktop` 文件。`~` 代表当前用户的主目录，`.desktop` 文件是用于在 GNOME 桌面上创建快捷方式的标准文件格式。

2. 写入的内容是 `.desktop` 文件的标准格式：
   - `[Desktop Entry]`：这行表示文件的类型是桌面入口。
   - `Name=Clash For Windows`：应用的名称。
   - `Exec=/home/user/.local/bin/cfw`：启动应用的命令或可执行文件的路径。
   - `Icon=/home/user/.local/bin/cfw`：应用的图标路径。这里应该是一个图标文件的路径，比如 `.png` 或 `.svg` 文件。
   - `Type=Application`：表示这是一个应用程序类型的入口。
   - `StartupNotify=true`：启动时显示通知。

3. `sudo chmod +x ~/.local/share/applications/clash.desktop`：这个命令给 `.desktop` 文件添加执行权限，这是必要的，因为桌面环境需要执行这个文件以创建快捷方式。

创建桌面图标的总体步骤和模板如下：

1. 打开终端。

2. 使用文本编辑器创建或编辑 `.desktop` 文件。例如：
   ```bash
   vim ~/.local/share/applications/your_app.desktop
   ```

3. 在 `.desktop` 文件中写入以下内容（替换为你的应用信息）：
   ```bash
   [Desktop Entry]
   Name=Your App Name
   Exec=/path/to/executable
   Icon=/path/to/icon
   Type=Application
   StartupNotify=true
   ```

4. 给 `.desktop` 文件添加执行权限：
   ```bash
   chmod +x ~/.local/share/applications/your_app.desktop
   ```

5. 完成后，桌面图标应该会出现在桌面上或在应用菜单中。如果没有显示，您可能需要注销并重新登录，或者重启 GNOME Shell。

### 完整模板

完整输出的示例：

```bash
# 使用 vim 编辑器打开或创建 your_app.desktop 文件
vim ~/.local/share/applications/your_app.desktop


# 在文件中写入以下内容
[Desktop Entry]
Name=Your App Name
Exec=/path/to/executable
Icon=/path/to/icon
Type=Application
StartupNotify=true

# 为文件添加执行权限
chmod +x ~/.local/share/applications/your_app.desktop
```

请将 `/home/user/.local/bin/cfw` 和 `/home/user/.local/bin/cfw` 中的 `/home/user` 替换为您的实际用户目录，并确保指定的执行文件和图标文件路径是正确的。

## Ubuntu20.04拨号上网

在Ubuntu 20.04上进行拨号上网通常用于连接通过电话线（如DSL）或移动宽带（如3G/4G）的互联网服务。以下是基本的设置步骤：

### DSL（数字用户线）拨号

对于通过电话线的DSL连接，通常需要使用PPPoE（点对点协议通过以夜间）进行拨号。这里的步骤是：

1. **安装PPPoE客户端**：
   - 打开终端，安装PPPoE客户端。在Ubuntu上，你可以使用以下命令：
     ```bash
     sudo apt-get update
     sudo apt-get install pppoeconf
     ```

2. **配置PPPoE连接**：
   - 运行PPPoE配置工具：
     ```bash
     sudo pppoeconf
     ```
   - 按照提示进行操作，输入你的ISP（互联网服务提供商）提供的用户名和密码。
   - 完成配置后，系统将创建一个新的网络连接，你可以使用此连接进行拨号上网。

3. **启动和停止连接**：
   - 使用以下命令启动连接：
     ```bash
     sudo pon dsl-provider
     ```
   - 使用以下命令停止连接：
     ```bash
     sudo poff dsl-provider
     ```

### 移动宽带拨号

对于移动宽带（如3G/4G）拨号，可以使用Ubuntu的网络管理器进行配置：

1. **插入移动宽带设备**：
   - 将你的移动宽带USB设备插入电脑。

2. **打开网络设置**：
   - 点击屏幕右上角的网络图标，选择“设置”。

3. **添加新的移动宽带连接**：
   - 在网络设置中，选择“移动宽带”标签。
   - 点击“添加新的移动宽带连接”。
   - 遵循配置向导的指示，选择你的国家、提供商，并输入必要的信息（如APN）。

4. **连接网络**：
   - 配置完成后，通常可以从网络菜单中选择新建的移动宽带连接进行连接。

### 注意事项

- 在配置DSL或移动宽带连接之前，请确保你有所需的硬件（如DSL调制解调器、移动宽带USB设备）和服务（如ISP账户）。

- 如果你使用的是移动宽带，确保你的数据计划在使用之前是激活的，并且设备在你的区域有覆盖。

- 某些特殊情况下，你的ISP可能提供特定的配置指南或需要特殊的设置，这时应参考ISP的指导。

如果在配置过程中遇到任何问题，可以查阅Ubuntu的官方文档或寻求社区的帮助。也可以考虑直接联系你的ISP，特别是如果你遇到网络连接方面的问题。









































## 搭建STM32开发环境

- 参考windows下用clion那一套
- 尝试wine+keil

## Wine

Wine（其名称是 "Wine Is Not an Emulator" 的递归缩写）是一款开源软件，用于在类Unix操作系统（如Linux、macOS和BSD）上运行Windows应用程序。它是一个兼容层，而不是一个模拟器。下面是关于Wine的更详细解释：

### 基本概念
1. **兼容层**：Wine作为兼容层，实现了Windows API的大部分功能，允许Windows程序直接在Unix-like系统上运行，而无需Windows操作系统的副本。

2. **非模拟器**：与模拟器不同，Wine不模拟内部Windows逻辑，也不模拟Windows使用的硬件。它只是翻译Windows API调用为POSIX调用，消除了系统之间的不兼容性。

3. **开源项目**：Wine是一个开源项目，由一个活跃的社区维护和开发。它在LGPL许可下发布，允许用户自由使用、修改和分发。

### 功能和特性
1. **程序运行**：使用Wine，可以在Linux和其他类Unix系统上运行许多原本只能在Windows上运行的程序，如游戏、办公软件等。

2. **Windows程序兼容**：Wine提供了对32位和64位Windows程序的支持。它还包括一个软件库，该库重新实现了Windows所提供的许多关键库（如用户界面、文件系统、图形、网络等）。

3. **配置工具**：Wine附带了一些工具来帮助配置和管理Windows程序，例如`winecfg`用于配置Wine设置，`winetricks`用于安装额外的库和组件。

4. **注册表编辑器**：Wine实现了自己的注册表编辑器，模拟了Windows注册表的功能，允许用户更改某些特定的设置。

### 使用方式

- 用户通常通过命令行接口安装和运行Windows程序。通过指定Windows可执行文件，Wine将启动并运行该程序。

- Wine创建了一个虚拟的Windows驱动环境，通常存储在用户主目录的 `.wine` 目录下。这个目录模拟了Windows的驱动结构，包括“C盘”、“D盘”等。

### 性能和兼容性
- **性能**：由于Wine直接翻译API调用而不是模拟整个操作系统，因此运行速度通常比完整的模拟器快。

- **兼容性**：Wine的兼容性取决于特定应用程序。一些应用程序可以无缝运行，而其他应用程序可能需要特定的调整或根本无法运行。

### 社区和支持
- **开发社区**：Wine有一个活跲的开发社区，不断更新和改进软件，增加对新应用程序的支持，修复bug。

- **文档和支持**：Wine项目提供了广泛的文档，包括用户指南、FAQ和应用程序数据库，后者详细介绍了不同Windows应用程序在Wine上的运行状况。

总的来说，Wine是一个强大的工具，使得在Linux或其他类Unix系统上运行Windows程序成为可能。虽然不是所有的Windows程序都能完美运行，但Wine对于那些希望在不放弃Windows应用的情况下使用Linux的用户来说，是一个非常有价值的解决方案。

## 百度网盘网页端大小突破限制

https://www.youxiaohou.com/zh-cn/linux.html#_3-%E9%80%89%E6%8B%A9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E5%99%A8

### 源码编译aria2

>aria2是一个开源的多协议命令行下载工具，可以用来从互联网上下载文件，支持HTTP、HTTPS、FTP、BitTorrent等多种下载协议。aria2具有高度的配置灵活性，能够在多种场景下满足用户的下载需求。以下是对aria2的详细解释：
>
>1. 多协议支持：aria2支持多种协议，包括HTTP、HTTPS、FTP、SFTP、BitTorrent等。这使得它成为一个强大的下载工具，可以用来下载各种类型的文件，无论是从网站、FTP服务器还是通过BitTorrent下载。
>
>2. 命令行工具：aria2是一个命令行工具，用户可以通过终端或命令行界面使用它。这使得它非常适合在服务器上执行下载任务，也可以在桌面操作系统中使用。
>
>3. 多连接下载：aria2支持同时建立多个连接来下载文件，这可以显著提高下载速度。用户可以配置同时建立的连接数，以适应不同的网络条件和服务器响应。
>
>4. 断点续传：aria2支持断点续传功能，即使下载被中断，也可以在之后重新开始，而不需要重新下载整个文件。这对于大文件或不稳定的网络连接非常有用。
>
>5. 高度可配置：aria2具有丰富的配置选项，用户可以通过配置文件或命令行参数来自定义其行为。这使得它非常适合满足各种特定需求，如限制带宽、设置代理、指定下载位置等。
>
>6. 轻量级和跨平台：aria2是一个轻量级的程序，占用较少的系统资源。它可在多个操作系统上运行，包括Linux、Windows和macOS。
>
>7. 插件支持：aria2支持插件，可以通过插件扩展其功能。例如，用户可以安装浏览器扩展，以便从浏览器中启动aria2下载。
>
>8. BitTorrent支持：aria2是一个强大的BitTorrent客户端，可以用来下载和上传种子文件。它支持磁力链接和种子文件的下载，并可以管理多个种子同时下载。
>
>总之，aria2是一个功能强大且灵活的下载工具，适用于各种下载需求。它的多协议支持、多连接下载、断点续传和高度可配置性使其成为一个流行的下载工具，特别是在需要下载大文件或使用BitTorrent下载时。通过命令行界面，用户可以轻松地控制和定制其下载任务。

![image-20231220221612372](/home/lyb/github/Typora_notes/image-20231220221612372.png)

![image-20231220221553152](/home/lyb/github/Typora_notes/image-20231220221553152.png)

## 安装typora

https://blog.csdn.net/qq_39779233/article/details/100551757

## 安装google

https://blog.csdn.net/snowdream86/article/details/106160498?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170296930016800227422257%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170296930016800227422257&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-106160498-null-null.142^v96^control&utm_term=ubuntu%20%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8&spm=1018.2226.3001.4187

## 安装Clash

https://github.com/Eggze2/Notes/blob/main/Notes/Others/Clash%20for%20Windows%20setup.md

## 安装微信，qq

https://blog.csdn.net/qq_44940689/article/details/133042525?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170296964316800186530482%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170296964316800186530482&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-133042525-null-null.142^v96^control&utm_term=ubuntu%20qq&spm=1018.2226.3001.4187

## 遇到的问题

### 外接显示器

- Bios配置为独显模式
- 笔记本的DP接口，带独显直连

### 蓝牙连接

解决方法：

1.修改蓝牙的控制器模式，打开蓝牙配置文件：

sudo vim /etc/bluetooth/main.conf

去掉ControllerMode的注释，并修改模式为bredr模式，即：ControllerMode = bredr，

2重启蓝牙服务：

```bash
sudo service bluetooth restart
```

### 登陆界面循环

非正常显卡驱动问题

第一步：进入ubuntu的正常进入系统的下一个选项（ubuntu高级选项）
第二步: 选择root权限,进入到命令行
第三步: 将profile文件中添加的内容删除

>这个问题涉及到Ubuntu 20.04登录界面循环的问题，这是一个常见的Linux系统问题。在理解为什么这三步可以解决问题之前，先了解一下问题的本质：
>
>Ubuntu登录界面循环问题通常发生在输入密码后，系统短暂尝试加载桌面，然后又返回到登录界面，这个过程不断重复。这通常是由于用户配置文件的错误或者图形界面设置的问题导致的。
>
>现在，让我们来分析您提到的三个步骤：
>
>1. **进入Ubuntu的高级选项**：在启动时选择“Ubuntu高级选项”，这通常意味着您将以恢复模式或类似的方式启动系统。这样做可以让您以特殊方式启动系统，比如以root权限，以便进行一些系统级别的修复或更改。
>
>2. **选择root权限进入命令行**：这一步骤让您以最高权限登录系统。这是必要的，因为要修复登录循环问题，您可能需要访问或修改通常需要高级权限的文件或设置。
>
>3. **删除profile文件中添加的内容**：这是关键步骤。`.profile`文件（位于用户的主目录中）包含在登录时加载的shell启动指令。如果在这个文件中添加了错误的命令或者损坏的脚本，它可能会导致图形界面无法正常加载。通过删除或修正`.profile`文件中的错误内容，您实际上是在清除可能导致登录循环的任何错误配置。
>
>总结来说，这三个步骤允许您安全地以最高权限访问系统，定位并修复可能导致登录循环的配置错误。这是一种有效的故障排除方法，特别是当问题与用户配置文件有关时。

### Ubuntu和Windows蓝牙设备不能共用

https://blog.csdn.net/10km/article/details/61201268

在Ubuntu和Windows的双系统配置中，蓝牙设备不能共用的问题通常是由于两个操作系统使用了不同的蓝牙配对和管理机制导致的。以下是一些详细的解释和可能的解决方案：

#### 原因解释

1. **不同的蓝牙堆栈**：Windows和Ubuntu使用不同的蓝牙软件堆栈。Windows使用自己的蓝牙驱动和管理工具，而Ubuntu通常使用BlueZ堆栈。
   
2. **配对信息的存储差异**：当你在一个系统中配对蓝牙设备时，这个配对信息是存储在当前操作系统中的。因此，当你切换到另一个操作系统时，这个配对信息不会自动转移。

3. **硬件地址冲突**：有些蓝牙设备在配对过程中会考虑计算机的硬件地址（MAC地址）。因为每个操作系统可能会以不同的方式处理这个地址，所以可能会出现冲突。

#### 可能的解决方案

1. **手动重新配对**：最简单的解决方案是在每次切换操作系统时手动重新配对蓝牙设备。这虽然不方便，但可以确保设备在当前系统中正常工作。

2. **使用专用蓝牙适配器**：为每个操作系统使用不同的蓝牙适配器。这样，每个系统都有其自己的配对信息，避免了信息不兼容的问题。

3. **编辑蓝牙配置文件**：对于一些技术熟练的用户来说，可以尝试手动同步两个系统中的蓝牙配对信息。这涉及编辑Linux系统中的蓝牙配置文件，复制Windows系统中的相关信息。

4. **使用双启动友好的蓝牙设备**：选择那些已知可以在双启动系统中较好工作的蓝牙设备。

5. **虚拟机解决方案**：如果使用虚拟机运行其中一个操作系统，可以通过虚拟机软件来管理蓝牙设备，这样可以更容易在两个系统之间共享蓝牙设备。

#### 结论

由于这个问题涉及到硬件和软件的复杂交互，因此没有一种通用的解决方案适用于所有配置。在某些情况下，这个问题可能无法完全解决，需要用户根据自己的需求和技术能力选择最合适的方法。

#### 配对信息

这段话涉及到的是操作系统如何处理蓝牙设备的配对信息。让我们来详细解析这个过程：

##### 配对信息的存储与管理

当你在一个操作系统（比如Windows）中配对蓝牙设备时，以下几个关键步骤会发生：

1. **配对过程**：这涉及到两个设备间的识别和安全连接的建立。在这个过程中，蓝牙设备与你的电脑交换了一些关键信息，比如加密密钥。

2. **信息存储**：一旦配对成功，这些信息（包括加密密钥和设备识别信息）被存储在当前操作系统的特定位置。在Windows中，这些信息可能被存储在注册表中；在Ubuntu中，通常存储在某个系统文件夹内的配置文件中。

3. **连接管理**：当你再次使用这个蓝牙设备时，操作系统会使用存储的配对信息来快速建立连接。

##### 跨操作系统的问题

当你在双系统配置（Windows和Ubuntu）中工作时，问题就出现了：

1. **不同的存储位置和格式**：Windows和Ubuntu将配对信息存储在不同的位置，且格式不同。这意味着在一个系统中配对的蓝牙设备的信息无法被另一个系统读取或理解。

2. **操作系统切换**：当你从Windows切换到Ubuntu（或反之）时，新的操作系统没有访问之前系统中存储的配对信息的能力。这意味着蓝牙设备在新系统中被视为未知设备，需要重新进行配对过程。

##### 结果

这导致的结果是，你每次从一个操作系统切换到另一个操作系统时，都需要重新配对你的蓝牙设备。这不仅仅是不便，而且在某些情况下，如果设备对配对次数有限制，可能会导致问题。

##### 可能的解决方法

- **双系统蓝牙共享**：尽管技术上挑战较大，但有一些高级用户可能尝试通过手动方式同步两个系统中的蓝牙配对信息。这涉及到对系统文件的深入了解和修改，风险较高。
- **使用两个不同的蓝牙适配器**：一种简单的解决方案是为每个操作系统使用一个单独的蓝牙适配器，这样每个系统都有自己的配对信息，不需要在系统之间共享。

这个问题突出了操作系统之间在硬件管理和信息共享方面的复杂性，特别是在像蓝牙这样的需要高度安全和私密性的技术领域。

>这两张图片是Linux系统中操作蓝牙配置文件的示例。以下是对两张图片内容的整合解释：
>
>### 第二张图解释
>
>在这张图中，用户以超级用户身份进入了`/var/lib/bluetooth`目录，这是蓝牙设备的信息通常存储的位置。目录名`70:32:17:42:FF:3F`很可能是本机蓝牙适配器的MAC地址。每个已配对的蓝牙设备都有一个以其MAC地址命名的子目录。
>
>用户首先尝试访问一个子目录（`70:32:17:43:FF:3F`），但由于某种原因失败了。随后，用户成功地进入了另一个子目录（`70:32:17:42:FF:3F`），并列出了该目录的内容，包括`cache`文件夹和`settings`文件，这些文件夹和文件用于存储与该蓝牙设备相关的配置和状态信息。
>
>### 第一张图解释
>
>在这张图中，用户查看了名为`info`的文件，这个文件在特定的子目录中（在这个例子中是`78:2B:64:E6:91:65`），这个子目录代表一个特定的配对蓝牙设备。`info`文件包含了以下信息：
>
>- **[General]**：包含设备的一般信息，比如设备名称`LYB`和设备类别。
>- **SupportedTechnologies**：展示了设备支持的技术类型，例如BR/EDR。
>- **Trusted**：表明设备是否被系统信任。
>- **Blocked**：表明设备是否被阻止连接。
>- **Services**：列出了设备提供的一系列蓝牙服务的UUIDs。
>- **[DeviceID]**：提供了设备的源、供应商编号、产品编号和版本。
>- **[LinkKey]**：显示了与设备配对时使用的链接密钥。
>
>### 整合解释
>
>这两张图展示了用户如何管理Linux系统中的蓝牙设备配对信息。用户首先确定了蓝牙适配器和已配对设备的MAC地址目录，然后查看了特定设备的`info`文件以理解其配对信息和配置状态。这个过程对于蓝牙设备的管理、故障排除以及手动编辑配对设置至关重要。通过这些文件，用户可以获取设备的详细信息，并在需要时进行必要的修改。

>#### 链接密钥（Link Key）的作用：
>
>在蓝牙技术中，**链接密钥**是用于设备间配对过程中建立安全连接的加密密钥。当两个蓝牙设备首次配对时，它们通过一系列的握手协议交换信息并创建这个链接密钥。这个过程通常涉及一个用户在一个设备上输入的PIN码，或者在无需PIN码的情况下使用低能耗蓝牙（BLE）的自动配对机制。
>
>链接密钥是一串数字，用于以下目的：
>
>- **验证**：在设备尝试重新连接时，链接密钥用来验证它们是否已经成功配对过。
>- **加密**：链接密钥用于加密设备间的通信，确保数据传输的安全性。
>
>#### 在Ubuntu中的链接密钥：
>
>如上所述，在Ubuntu（或其他基于Linux的系统）中，链接密钥存储在`/var/lib/bluetooth/{适配器的MAC地址}/{设备的MAC地址}/info`文件中。这个文件是由系统自动创建和管理的，通常不需要用户直接编辑。
>
>#### 在Windows中的链接密钥：
>
>在Windows操作系统中，链接密钥的处理方式不同。Windows将这些密钥存储在系统注册表中，具体位置可能因Windows的版本而异，但通常在`HKEY_LOCAL_MACHINE`的蓝牙设备枚举下。用户通常不会直接访问或编辑注册表中的这些信息，因为Windows提供了图形界面的设备管理器来处理蓝牙设备的配对和连接。
>
>#### Windows和Ubuntu中链接密钥的区别：
>
>- **存储位置**：Ubuntu在文件系统中存储，而Windows在注册表中存储。
>- **访问方式**：Ubuntu的文件可以直接用文本编辑器查看和编辑，而Windows的注册表需要使用注册表编辑器。
>- **用户界面**：Ubuntu可能允许更多的命令行交互，而Windows更侧重于图形界面。
>- **兼容性**：由于存储格式和位置的差异，两个系统之间的链接密钥不共享，这意味着在双启动系统中，同一个蓝牙设备需要在每个操作系统中分别配对。
>
>在双启动环境中，由于这些差异，你不能简单地从一个系统取得链接密钥然后复制到另一个系统来绕过配对过程，因为每个操作系统都有其独特的方式来生成和存储这个密钥。

### ubuntu系统卡顿

![image-20231220200148745](/home/lyb/github/Typora_notes/image-20231220200148745.png)在Ubuntu系统中，您可以通过图形界面或命令行来查看并安装推荐的显卡驱动版本。

### 通过图形界面：

1. 打开“软件和更新”设置。
2. 点击“附加驱动”标签页。
3. 系统会自动搜索可用的驱动程序。
4. 一旦完成，它会列出所有可用的驱动程序选项，包括推荐的驱动程序。通常，推荐的驱动程序旁边会有一个“推荐”标签。

选择推荐的驱动程序，然后点击“应用更改”来安装。

### 通过命令行：

您也可以通过命令行来查找和安装推荐的驱动程序。打开终端并使用以下命令：

```bash
ubuntu-drivers devices
```

这个命令会列出您的系统硬件和为它们推荐的驱动程序。为了自动安装推荐的显卡驱动，您可以使用：

```bash
sudo ubuntu-drivers autoinstall
```

该命令将安装为您的硬件推荐的所有驱动程序，包括显卡驱动。

请注意，在进行驱动程序更改之前，建议备份您的数据，以防万一安装新驱动程序后出现问题。安装完成后，通常需要重启您的电脑以使更改生效。

![image-20231220200250065](/home/lyb/github/Typora_notes/image-20231220200250065.png)

您提供的截图显示了一个Ubuntu终端窗口，其中包含了两个命令的输出结果。

1. `uname -r`：这是一个显示当前正在运行的Linux内核版本的命令。输出`5.15.0-91-generic`表明您的系统正在运行5.15.0-91版本的Linux内核，这是Ubuntu提供的一个稳定版本。

2. `ubuntu-drivers devices`：这个命令会列出系统上检测到的硬件设备以及可用的驱动程序。在您的截图中，命令输出显示了有关NVIDIA显卡的信息：

   - `vendor`：显示硬件供应商是NVIDIA Corporation。
   - `modalias`：提供了设备的模态别名，这是内核用来匹配设备与其驱动程序的标识符。
   - `driver`：下面列出了一系列NVIDIA驱动程序版本。其中包括多个不同版本的闭源（non-free）NVIDIA驱动，还有开源的Nouveau驱动（xserver-xorg-video-nouveau）。

   - `nvidia-driver-470` 和 `nvidia-driver-525` 等是NVIDIA闭源驱动程序的不同版本。版本号越高通常意味着驱动越新。
   - `nvidia-driver-535` 被标记为“recommended”，这意味着系统推荐使用这个版本的驱动程序，因为它可能提供了最佳的稳定性和性能。

通常，推荐使用系统推荐的驱动程序，因为它已经经过测试，被认为与您当前的系统配置最兼容。

如果您遇到显卡驱动相关的问题，或者需要安装或更新驱动，您可以选择系统推荐的驱动来安装。可以通过图形界面的“软件和更新”中的“附加驱动”选项来安装，或者使用命令行：

```bash
sudo ubuntu-drivers autoinstall
```

安装推荐的驱动程序后，通常需要重启计算机以应用更改。
