# 履带车上位机

## speedparam.cfg

```python
#!/usr/bin/env python
PACKAGE = "robot_bringup"
 
from dynamic_reconfigure.parameter_generator_catkin import *
 
 
gen = ParameterGenerator()
 
gen.add("speedparam_x",        int_t, 0, "the param of msg.linear.x",  1000, 1125,  2000)
gen.add("speedparam_y",        int_t, 0, "the param of msg.linear.y",  4000, 4655,  5000)

# gen.add("acc_x",        double_t, 0, "the acc x velocity of vehicle ",  .5, 0,  2)
# gen.add("obtain_name",  str_t,    0, "topic name" , "fff")
# gen.add("acc_y",        double_t, 0,  "the acc y velocity of vehicle", 0.5, 0 , 2)
# gen.add("use_dwa",      bool_t,   0, "whether use dwa or not", True )
# name：参数名，使用字符串描述；
# type：定义参数的类型，可以是int_t, double_t, str_t, 或者bool_t；
# level：需要传入参数动态配置回调函数中的掩码，在回调函数中会修改所有参数的掩码，表示参数已经进行修改；
# description：描述参数作用的字符串；
# default：设置参数的默认值；
# min：可选，设置参数的最小值，对于字符串和布尔类型值不生效；
# max：可选，设置参数的最大值，对于字符串和布尔类型值不生效；
 
# 这种方法可以生成一个参数值，也可以使用如下方法生成一个枚举类型的值：
 
# size_enum = gen.enum([ gen.const("Small",      int_t, 0, "A small constant"),
#                        gen.const("Medium",     int_t, 1, "A medium constant"),
#                        gen.const("Large",      int_t, 2, "A large constant"),
#                        gen.const("ExtraLarge", int_t, 3, "An extra large constant")],
#                      "An enum to set size")
 
# gen.add("size", int_t, 0, "A size parameter which is edited via an enum", 1, 0, 3, edit_method=size_enum)
 
# 最后一个参数是生成的动态参数头文件名字，如这里生成的应是testConfig.h
exit(gen.generate(PACKAGE, "robot_bringup", "speedparam"))

------------------------------------------------------------------------------------------------

#!/usr/bin/env python
# 设置包名称
PACKAGE = "robot_bringup"

from dynamic_reconfigure.parameter_generator_catkin import *

# 创建参数生成器
gen = ParameterGenerator()

# 添加整型参数speedparam_x，用于配置msg.linear.x的参数
gen.add("speedparam_x", int_t, 0, "the param of msg.linear.x", 1000, 1125, 2000)
# 添加整型参数speedparam_y，用于配置msg.linear.y的参数
gen.add("speedparam_y", int_t, 0, "the param of msg.linear.y", 4000, 4655, 5000)

# 可以继续添加其他类型的参数，如双精度浮点数、字符串或布尔值

# 生成动态重配置的配置文件，参数会被用于robot_bringup包的speedparam配置
exit(gen.generate(PACKAGE, "robot_bringup", "speedparam"))

```

这段Python脚本用于ROS（Robot Operating System）的动态重配置（dynamic reconfigure）功能，它创建了一组动态可配置的参数。以下是对代码的详细解释：

### 代码解释

1. **导入和包声明**：
   - `#!/usr/bin/env python` 是一个shebang行，用于指定脚本的解释器。
   - `PACKAGE = "robot_bringup"` 定义了一个字符串常量`PACKAGE`，存储ROS包的名称。
   - `from dynamic_reconfigure.parameter_generator_catkin import *` 导入ROS的动态重配置参数生成器模块。
2. **参数生成器初始化**：
   - `gen = ParameterGenerator()` 创建一个`ParameterGenerator`实例，用于生成动态配置参数。
3. **添加动态参数**：
   - `gen.add("speedparam_x", int_t, 0, "the param of msg.linear.x", 1000, 1125, 2000)`：添加一个名为`speedparam_x`的整型参数，附带描述、默认值、最小值和最大值。
   - `gen.add("speedparam_y", int_t, 0, "the param of msg.linear.y", 4000, 4655, 5000)`：添加一个名为`speedparam_y`的整型参数，类似地设置其属性。
4. **参数属性说明**：
   - `name`：参数名称。
   - `type`：参数类型，可以是`int_t`（整型）、`double_t`（双精度浮点型）、`str_t`（字符串）或`bool_t`（布尔）。
   - `level`：参数更改的级别，用于动态重配置回调函数。
   - `description`：参数描述。
   - `default`：默认值。
   - `min` 和 `max`：参数的最小值和最大值。
5. **生成动态配置文件**：
   - `exit(gen.generate(PACKAGE, "robot_bringup", "speedparam"))`：调用`generate`方法生成动态重配置的配置文件。这些文件用于ROS节点以动态方式更改配置。

## robot.h

```c++
#ifndef __ROBOT_H__
#define __ROBOT_H__

#include <ros/ros.h>
#include <ros/time.h>
#include <geometry_msgs/TransformStamped.h>
#include <tf/transform_broadcaster.h>
#include <nav_msgs/Odometry.h>
#include <boost/asio.hpp>
#include <geometry_msgs/Twist.h>
#include "robot_bringup/mbot_linux_serial.h"

namespace robot
{
    class robot
    {
        public:
            robot();
            ~robot();
            bool init();                  
            void deal(double RobotV, double RobotYawRate);
            void handle_read( char buf[], boost::system::error_code ec,
	            std::size_t bytes_transferred );
            void read_from_serial();
            void call_handle();
        // private:
        //     void calcOdom();               //里程计计算
        //     void pubOdomAndTf();           //发布Odom和tf
        
        private:
            ros::Time current_time_, last_time_; //时间

            double x_;                     //机器人位姿
            double y_;
            double th_;

            double vx_;                    //机器人x方向速度
            double vy_;                    //机器人y方向速度
            double vth_;                   //机器人角速度
            unsigned char sensFlag_;       //通信预留发送和接收标志位，可进行信号控制使用
            unsigned char receFlag_;
            
            ros::NodeHandle nh;
            ros::Publisher pub_;
            tf::TransformBroadcaster odom_broadcaster_;
    };
    
}

#endif 


```

这段代码是一个用于机器人控制的ROS（Robot Operating System）节点的C++头文件。它定义了一个名为`robot`的类，用于处理机器人的运动控制和通信。以下是对代码中各部分的详细解释：

### 头文件保护
- `#ifndef __ROBOT_H__` 和 `#endif`：这是一个预处理指令，用于防止头文件被多次包含。如果`__ROBOT_H__`未定义，则定义它，并在文件的最后取消定义。

### 头文件引入

- 代码包含了多个必要的头文件，这些文件提供了编写机器人控制程序所需的各种功能：
  - `ros/ros.h` 和 `ros/time.h`：用于ROS功能和时间管理。
  - `geometry_msgs/TransformStamped.h` 和 `nav_msgs/Odometry.h`：提供机器人位姿和里程计信息的消息类型。
  - `tf/transform_broadcaster.h`：用于发布坐标变换信息。
  - `boost/asio.hpp`：Boost Asio库，用于底层I/O操作，如串行通信。
  - `geometry_msgs/Twist.h`：提供线速度和角速度的消息类型。
  - `robot_bringup/mbot_linux_serial.h`：可能是用于机器人与下位机通信的自定义头文件。

### 命名空间和类定义
- `namespace robot { ... }`：定义了一个命名空间`robot`，这有助于防止名称冲突。
- `class robot { ... }`：定义了一个名为`robot`的类。

### 类成员
- **公共成员**:
  - 构造函数`robot()` 和 析构函数 `~robot()`。
  - `bool init()`: 用于初始化机器人，可能包括启动串行通信和设置ROS参数。
  - `void deal(double RobotV, double RobotYawRate)`: 处理机器人的运动，根据线速度`RobotV`和角速度`RobotYawRate`控制机器人。
  - `void handle_read(char buf[], boost::system::error_code ec, std::size_t bytes_transferred)`: 处理从串行端口读取的数据。
  - `void read_from_serial()`: 从串行端口读取数据。
  - `void call_handle()`: 可能用于周期性调用`handle_read`函数。

- **私有成员**:
  - 时间相关变量`ros::Time current_time_`, `last_time_`。
  - 机器人的位置`x_`, `y_`, `th_` 和 速度`vx_`, `vy_`, `vth_`。
  - 通信标志位`sensFlag_` 和 `receFlag_`。
  - ROS节点句柄`ros::NodeHandle nh`。
  - 一个发布者`ros::Publisher pub_`。
  - 一个用于发布TF变换的`tf::TransformBroadcaster odom_broadcaster_`。

### 总结
这个头文件定义了一个`robot`类，该类是一个为机器人提供运动控制和串行通信功能的ROS节点的一部分。它包含了初始化、数据处理、串行通信读取等功能的方法，以及机器人状态和ROS通信所需的成员变量。通过这个类，可以实现对机器人的高层次控制，如处理运动命令、读取传感器数据等。

## robot.cpp

```c++
#include <vector>
#include "robot_bringup/robot.h"
#include "robot_bringup/mbot_linux_serial.h"
//#include <boost/bind.hpp>
//#include <boost/asio.hpp>
using namespace std;

namespace robot
{
    robot::robot():x_(0.0), y_(0.0), th_(0.0),vx_(0.0), vy_(0.0), vth_(0.0),sensFlag_(0),receFlag_(0) {}//构造函数
    robot::~robot(){}            //析构函数

    /********************************************************
    函数功能：串口参数初始化、时间变量初始化、实例化发布对象
    入口参数：无
    出口参数：bool
    ********************************************************/
    bool robot::init()
    {
        // 串口初始化连接
        serialInit();
               
        ros::Time::init();
        current_time_ = ros::Time::now();
        last_time_ = ros::Time::now();	
        
        return true;
    }
 
    /********************************************************
    函数功能：对电机转动和停止进行判定
    入口参数：RobotV,RobotYawRat
    出口参数：StopFlag
    ********************************************************/
    void robot::deal(double RobotV, double RobotYawRate)
    {
        unsigned char StopFlag;
        if(RobotV==0 && RobotYawRate==0)//电机正常停止模式
        {
            StopFlag=0x02;
        }else
        {
            StopFlag=0x01;//停止
        }
        writeSpeed(RobotV,RobotYawRate,StopFlag);
        ROS_INFO("RobotV RobotYawRate : %f %f",RobotV,RobotYawRate);
    }
}


```

提供的代码似乎是一个使用ROS（Robot Operating System，机器人操作系统）设计的C++程序的一部分，主要用于机器人控制。我们来详细解析这段代码：

### 头文件引用和命名空间

- `#include <vector>`：引入了标准模板库（STL）的vector头文件，允许使用`vector`类。
- `#include "robot_bringup/robot.h"`：引入了`robot`类的头文件，这可能是一个为机器人操作定义的自定义类。
- `#include "robot_bringup/mbot_linux_serial.h"`：引入了用于Linux系统上串行通信的头文件，可能特定于机器人的硬件。
- `// #include <boost/bind.hpp>`：（已注释）这将包含Boost库的bind功能，用于函数和参数绑定。
- `// #include <boost/asio.hpp>`：（已注释）这将包含Boost库的ASIO头文件，用于网络和底层I/O编程。
- `using namespace std;`：允许直接使用`std`命名空间中的元素。

### 命名空间和类定义
- 声明了`namespace robot`命名空间，表示接下来的定义属于`robot`命名空间。
- 在`namespace robot`内部，定义了一个带有公共和私有成员的`robot`类。

### 构造函数和析构函数
- `robot::robot()`：构造函数初始化成员变量如`x_`、`y_`、`th_`、`vx_`、`vy_`、`vth_`、`sensFlag_`和`receFlag_`为零。这些可能用于存储机器人的位置、速度和状态标志。

  - `robot::robot()` 表示这是`robot`类的构造函数。
  - 在冒号后面的部分称为**初始化列表**，用于在创建对象时初始化成员变量。

  - ```
    x_(0.0), y_(0.0), th_(0.0), vx_(0.0), vy_(0.0), vth_(0.0), sensFlag_(0), receFlag_(0)
    ```

     这些都是成员初始化语句。每个成员变量都被初始化为特定的值：

    - `x_`, `y_`, `th_` 分别被初始化为 `0.0`，这些可能代表机器人的位置和方向。
    - `vx_`, `vy_`, `vth_` 也被初始化为 `0.0`，这些可能代表机器人的线速度和角速度。
    - `sensFlag_` 和 `receFlag_` 被初始化为 `0`，这可能是用于通信的标志位。

- `robot::~robot()`：析构函数，目前为空。

  - `robot::~robot()` 表示这是`robot`类的析构函数。
  - 析构函数的主体为空，这意味着在对象被销毁时不需要执行特定的操作。这在类中不管理动态分配的资源或其他需要特殊清理的资源时是常见的。


### 成员函数：`init`

- `bool robot::init()`：此函数初始化串行通信（`serialInit()`），设置ROS时间跟踪，并返回`true`。这表示初始化成功。

### 成员函数：`deal`
- `void robot::deal(double RobotV, double RobotYawRate)`：
  - 接受速度（`RobotV`）和偏航率（`RobotYawRate`）作为参数。
  - 根据这些值决定机器人是否应该停止。如果`RobotV`和`RobotYawRate`都为零，则设置`StopFlag`表示正常停止；否则，表示不同的停止条件。
  - 调用`writeSpeed(RobotV,RobotYawRate,StopFlag)`来执行运动命令。
  - 使用`ROS_INFO`记录速度和偏航率值。

### ROS（机器人操作系统）的特点
- 代码使用了ROS的功能，如`ros::Time::now()`，表明它是ROS节点的一部分，用于控制机器人。
- `ROS_INFO`用于日志记录，这在ROS节点中是常见做法。

### 总结
这段C++代码片段是一个机器人控制系统的一部分，使用ROS。它定义了一个`robot`类，具有初始化和运动控制的方法，处理串行通信和基于速度和偏航率输入的机器人运动。使用ROS表明这可能是更大的机器人系统的一部分，其中这段代码与其他ROS节点交互，以实现全面的机器人控制和操作。

## robot_bringup.cpp

```c++
#include "robot_bringup/robot.h"
#include <dynamic_reconfigure/server.h>
#include "robot_bringup/speedparamConfig.h"
#include "ros/ros.h"
#include "mbot_linux_serial.h"

double RobotV_ = 0;
double RobotYawRate_ = 0;
int speedparam_x;
int speedparam_y;


/* 传递速度系数参数 */
namespace robot_bringup { // 这个命名空间必须与ROS包名一致

    // 回调函数，用于处理速度参数配置的变更
    void speedcallback(speedparamConfig &config, uint32_t level) {
        // 从配置中获取线速度和角速度的参数，并更新相应变量
        speedparam_x = config.speedparam_x;
        speedparam_y = config.speedparam_y;

        // 记录一条信息，表明速度参数回调函数已成功执行
        ROS_INFO("success to speedcallback");
    }

}


/* 速度控制消息的回调函数 */
// 处理机器人运动控制命令的回调函数
void cmdCallback(const geometry_msgs::Twist& msg)
{
    // 计算并更新机器人的线速度，基于接收到的线速度消息和速度参数
    // msg.linear.x的初始值是0.5，speedparam_x的值是1125
    RobotV_ = msg.linear.x * (-1) * speedparam_x;

    // 计算并更新机器人的角速度，基于接收到的角速度消息和速度参数
    // speedparam_y的值是4650
    RobotYawRate_ = msg.angular.z * speedparam_y;
    
    // 记录一条信息，表明cmdCallback函数已成功执行
    ROS_INFO("success to cmdCallback");
}

    
int main(int argc, char** argv)
{
    //初始化ROS节点
    ros::init(argc, argv, "mbot_bringup");
    ros::NodeHandle nh;
    ros::NodeHandle nhPrivate("~");
    robot::robot myrobot;

    //serialInit();
    
    // 通过param获取参数
    // 从ROS参数服务器获取速度参数speedparam_x
    // 如果参数未设置，则默认为1125
    nhPrivate.param("speedparam_x", speedparam_x, 1125);

    // 从ROS参数服务器获取速度参数speedparam_y
    // 如果参数未设置，则默认为4655
    nhPrivate.param("speedparam_y", speedparam_y, 4655);

    
    //创建动态参数服务，并绑定回调函数
    // 定义一个动态重配置服务器，用于处理机器人速度参数的变更
    dynamic_reconfigure::Server<robot_bringup::speedparamConfig> server;

    // 将速度参数变更的处理函数speedcallback绑定到回调ser
    dynamic_reconfigure::Server<robot_bringup::speedparamConfig>::CallbackType ser = boost::bind(&robot_bringup::speedcallback, _1, _2);

    // 设置动态重配置服务器以使用ser回调
    server.setCallback(ser);


    //初始化robot
    if(!myrobot.init())
        ROS_ERROR("myrobot initialized failed.");
        
    ROS_INFO("myrobot initialized successful.");
    // ROS_INFO("speedparam_x %d",speedparam_x);
    ros::Subscriber sub = nh.subscribe("cmd_vel", 50, cmdCallback);

    //循环运行
    ROS_INFO("start to loop");
    ros::Rate loop_rate(10);
    while (ros::ok()) 
    {
        ros::spinOnce();
        
        //机器人控制RobotV_,RobotYawRate_这两个参数传入到robot.cpp/bool robot::deal，再传入到mbot_linux_serial.cpp中
        //通过deal对RobotV_和RobotYawRate_进行判定电机的转动和停止
        myrobot.deal(RobotV_,RobotYawRate_);//传入到robot.cpp文件中 robot::deal()
        
        loop_rate.sleep();
    }

    return 0;
}


```

这段代码是一个用于机器人控制的ROS（Robot Operating System）节点，它使用C++编写。代码主要负责处理速度控制和参数动态配置。下面是对代码的详细解释：

### 头文件引用

- `#include "robot_bringup/robot.h"`：引入自定义的`robot`类。
- `#include <dynamic_reconfigure/server.h>`：引入ROS的动态配置服务器库，用于在运行时调整参数。
- `#include "robot_bringup/speedparamConfig.h"`：引入动态配置参数的定义。
- `#include "ros/ros.h"`：引入ROS的主要功能。
- `#include "mbot_linux_serial.h"`：可能是用于机器人的串行通信。

### 全局变量
- `double RobotV_ = 0;`
- `double RobotYawRate_ = 0;`
- `int speedparam_x;`
- `int speedparam_y;`  
  这些变量用于存储机器人的速度、偏航率和速度参数。

### 动态配置回调函数
- `void speedcallback(speedparamConfig &config, uint32_t level)`：这个函数在动态配置参数改变时被调用，更新`speedparam_x`和`speedparam_y`的值，并打印日志信息。

>这段代码定义了一个名为`robot_bringup`的命名空间内的函数`speedcallback`。以下是对代码的详细解释，以及相应的中文注释：
>
>### 代码解释
>
>- **命名空间**：
>
>  - `namespace robot_bringup { ... }`：定义了一个名为`robot_bringup`的命名空间。命名空间在C++中用于组织代码，防止名称冲突。此处的`robot_bringup`可能与ROS包名对应，用于将代码组织在与特定ROS包相关的逻辑单元内。
>
>- **函数定义**：
>
>  - ```
>    void speedcallback(speedparamConfig &config, uint32_t level)
>    ```
>
>    ：定义了一个名为
>
>    ```
>    speedcallback
>    ```
>
>    的函数。这个函数可能是一个回调函数，用于处理某种类型的事件或数据。
>
>    - `speedparamConfig &config`：函数的第一个参数是一个名为`config`的`speedparamConfig`类型的引用，这可能是一个包含配置参数的结构体或类。
>    - `uint32_t level`：函数的第二个参数是一个名为`level`的`uint32_t`类型，这可能表示回调函数被触发的级别或类型。
>
>- **函数实现**：
>
>  - `speedparam_x = config.speedparam_x;` 和 `speedparam_y = config.speedparam_y;`：这两行代码从`config`对象中获取`speedparam_x`和`speedparam_y`的值，并将它们分别赋值给全局或外部变量`speedparam_x`和`speedparam_y`。
>  - `ROS_INFO("success to speedcallback");`：使用ROS的日志功能打印信息，表示回调函数已成功执行。


### 速度控制消息回调函数
- `void cmdCallback(const geometry_msgs::Twist& msg)`：这个函数处理速度控制消息。它根据传入的`msg`和速度系数参数计算新的速度（`RobotV_`）和偏航率（`RobotYawRate_`），并打印日志信息。

>这段代码定义了一个名为`cmdCallback`的函数，它似乎是用于处理机器人运动控制命令的回调函数。以下是对这段代码的详细解释和相应的中文注释：
>
>### 代码解释
>
>- **函数定义**：
>  - `void cmdCallback(const geometry_msgs::Twist& msg)`：定义了一个名为`cmdCallback`的函数。这个函数接受一个常量引用参数`msg`，其类型为`geometry_msgs::Twist`。在ROS中，`geometry_msgs::Twist`是一个用于表示速度的标准消息类型，其中包含线速度和角速度。
>- **函数实现**：
>  - `RobotV_ = msg.linear.x * (-1) * speedparam_x;`：这一行计算机器人的线速度。它从`msg`消息中获取线性速度的`x`分量（通常表示前进或后退的速度），将其乘以`-1`（可能是为了调整方向或坐标系），然后再乘以一个速度参数`speedparam_x`。
>  - `RobotYawRate_ = msg.angular.z * speedparam_y;`：这一行计算机器人的角速度。它从`msg`消息中获取角速度的`z`分量（通常表示绕垂直轴的旋转），然后乘以一个速度参数`speedparam_y`。
>  - `ROS_INFO("success to cmdCallback");`：使用ROS的日志功能打印信息，表明回调函数已成功执行。


### 主函数
- `int main(int argc, char** argv)`：程序的入口点。
  - 初始化ROS节点。
  - 创建`robot`类的实例。
  - 从参数服务器获取`speedparam_x`和`speedparam_y`的默认值。
  
    >这段代码是用于在ROS（Robot Operating System）节点中获取参数值的C++代码。它使用了ROS的参数服务器功能来获取配置参数。以下是对代码的详细解释和相应的中文注释：
    >
    >### 代码解释
    >
    >1. **获取参数值**：
    >   - `nhPrivate.param("speedparam_x", speedparam_x, 1125);`：这行代码从ROS的参数服务器中获取名为`"speedparam_x"`的参数值，并将其存储在变量`speedparam_x`中。如果参数服务器中没有这个参数，那么`speedparam_x`将被赋予默认值`1125`。
    >   - `nhPrivate.param("speedparam_y", speedparam_y, 4655);`：这行代码的作用类似，它获取名为`"speedparam_y"`的参数值，并将其存储在变量`speedparam_y`中。如果参数服务器中没有这个参数，那么`speedparam_y`将被赋予默认值`4655`。
    >2. **ROS节点句柄**：
    >   - `nhPrivate` 是一个ROS节点句柄（`ros::NodeHandle`类型），用于与ROS的参数服务器进行交互。这个句柄可能是私有的，意味着它处理的参数是私有命名空间下的参数。
  - 设置动态配置服务器和回调函数。
  
    >这段代码设置了一个动态重配置（dynamic reconfigure）服务器，用于ROS（Robot Operating System）。动态重配置允许ROS节点在运行时改变参数，而无需重新启动节点。以下是对这段代码的详细解释和相应的中文注释：
    >
    >### 代码解释
    >
    >1. **动态重配置服务器定义**：
    >   - `dynamic_reconfigure::Server<robot_bringup::speedparamConfig> server;`：这行代码定义了一个名为`server`的动态重配置服务器。这个服务器用于处理`robot_bringup::speedparamConfig`类型的配置，这可能是一个自定义的配置类型，用于设置和调整机器人的速度参数。
    >2. **回调函数绑定**：
    >   - `dynamic_reconfigure::Server<robot_bringup::speedparamConfig>::CallbackType ser = boost::bind(&robot_bringup::speedcallback, _1, _2);`：这行代码创建了一个回调函数`ser`。它使用`boost::bind`将`robot_bringup::speedcallback`函数绑定为回调，`_1`和`_2`是占位符，代表回调函数的参数。这意味着当配置参数改变时，`speedcallback`函数将被调用。
    >3. **设置回调**：
    >   - `server.setCallback(ser);`：这行代码将`ser`回调函数设置到`server`服务器上。这样，当动态重配置服务器接收到参数变更请求时，将调用`speedcallback`函数。
  - 订阅`cmd_vel`话题以接收速度控制命令。
  - 进入循环，不断调用`deal`函数控制机器人。

### ROS NodeHandle
- `ros::NodeHandle nh`和`ros::NodeHandle nhPrivate("~")`用于与ROS通信和处理参数。

### 订阅者和发布者
- `ros::Subscriber sub = nh.subscribe("cmd_vel", 50, cmdCallback)`：创建一个订阅者来接收`cmd_vel`话题的消息。

### 循环运行

- 在`while (ros::ok())`循环中，不断调用`ros::spinOnce()`处理回调函数，然后调用`myrobot.deal`来控制机器人。

### 总结

此代码设置了一个ROS节点，用于接收和处理速度控制命令，通过动态参数调整速度系数，并控制机器人的运动。这种设计允许在运行时调整速度参数，使得控制更灵活和适应不同的操作条件。代码中使用了ROS的标准实践，如消息订阅、动态配置服务和自定义类的使用。

### 动态重配置服务器和动态重配置客户端

在提供的代码中，体现了动态重配置服务器（Dynamic Reconfigure Server）的部分，但并未直接展示动态重配置客户端（Dynamic Reconfigure Client）。下面详细解释这两个部分：

#### 动态重配置服务器

动态重配置服务器在代码中的体现如下：

1. **创建服务器**：
   
   ```cpp
   dynamic_reconfigure::Server<robot_bringup::speedparamConfig> server;
   ```
   这行代码创建了一个动态重配置服务器`server`。服务器使用了`robot_bringup::speedparamConfig`作为其配置类型，这个类型定义了可以动态更改的参数。
   
2. **绑定回调函数**：
   ```cpp
   dynamic_reconfigure::Server<robot_bringup::speedparamConfig>::CallbackType ser = boost::bind(&robot_bringup::speedcallback, _1, _2);
   server.setCallback(ser);
   ```
   这里首先创建了一个回调函数`ser`，然后将它绑定到动态重配置服务器`server`上。当参数通过动态重配置客户端更改时，`speedcallback`函数会被调用。

3. **回调函数实现**：
   
   ```cpp
   namespace robot_bringup {
       void speedcallback(speedparamConfig &config, uint32_t level) {
           speedparam_x = config.speedparam_x;
           speedparam_y = config.speedparam_y;
           ROS_INFO("success to speedcallback");
       }
   }
   ```
   这个`speedcallback`回调函数会在动态参数发生变化时被调用，用于更新相关的内部变量（如`speedparam_x`和`speedparam_y`）。

#### 动态重配置客户端

虽然代码中没有直接展示动态重配置客户端，但客户端通常是独立于你的节点代码之外的。它可以是：

- **rqt_reconfigure**：一个常用的ROS工具，提供图形用户界面，用于在运行时动态地更改配置参数。
- **命令行工具**：使用`rosrun dynamic_reconfigure dynparam`等命令来实现参数的动态更改。

客户端与你的服务器交互，发送新的配置参数，这些参数通过回调函数`speedcallback`应用于你的节点。

>基于您提供的代码，以下是使用动态重配置客户端（如`rqt_reconfigure`或命令行工具）来动态更改配置参数的详细步骤：
>
>#### 步骤 1: 运行您的ROS节点
>
>首先，确保您的ROS节点（包含动态重配置服务器）正在运行。在终端中运行您的节点：
>
>```bash
>rosrun your_package_name node_executable_name
>```
>
>这里，`your_package_name`是您的ROS包名，`node_executable_name`是您的节点可执行文件的名称。
>
>#### 步骤 2: 使用rqt_reconfigure
>
>`rqt_reconfigure`提供了一个图形界面，用于更改动态重配置服务器的参数。
>
>1. **启动rqt_reconfigure**：
>     在新的终端窗口中运行：
>   ```bash
>   rosrun rqt_reconfigure rqt_reconfigure
>   ```
>
>2. **选择节点**：
>     在`rqt_reconfigure`窗口中，选择您的节点（例如，`mbot_bringup`）。
>
>3. **调整参数**：
>     使用提供的滑块或输入框更改参数（如`speedparam_x`和`speedparam_y`）。当您更改这些参数时，动态重配置服务器将调用`speedcallback`回调函数。
>
>#### 步骤 3: 使用命令行工具
>
>如果您更倾向于使用命令行工具来更改参数，可以使用以下命令：
>
>1. **更改参数**：
>     使用`rosrun dynamic_reconfigure dynparam`命令来设置新的参数值。例如：
>   ```bash
>   rosrun dynamic_reconfigure dynparam set /node_name speedparam_x new_value
>   ```
>   将`/node_name`替换为您的节点名称，`speedparam_x`为要更改的参数名称，`new_value`为新的参数值。
>
>2. **检查更新**：
>     使用以下命令来检查参数是否正确更新：
>   ```bash
>   rosrun dynamic_reconfigure dynparam get /node_name
>   ```
>
>#### 注意
>
>- 确保ROS环境已经正确设置，且所有的ROS节点和工具都在同一个ROS master下运行。
>- 当您使用`rqt_reconfigure`或命令行工具更改参数时，`speedcallback`函数将被触发，更新相应的参数值，并在ROS节点中应用这些更改。
>- `rqt_reconfigure`提供了一个更直观的方式来观察和更改参数，而命令行工具更适合脚本化或自动化的操作。
>
>通过这些步骤，您可以实现在ROS节点运行时动态调整配置参数，而无需重新启动节点。

#### 总结

你的代码展示了动态重配置服务器的设置和使用，它允许你的ROS节点在运行时接收和应用配置参数的更改。而动态重配置客户端通常是通过ROS提供的工具（如rqt_reconfigure）或命令行来实现的，用于实际发送这些参数更改请求。

## mbot_linux_serial.cpp

```c++
#include "robot_bringup/mbot_linux_serial.h"
#include "string.h"
#include <boost/bind.hpp>
#include "ros/ros.h"
#include "std_msgs/String.h"
#include "serial/serial.h"

using namespace std;
using namespace boost::asio;

serial::Serial ser;
#define sBUFFER_SIZE 1024
#define rBUFFER_SIZE 1024
unsigned char s_buffer[sBUFFER_SIZE];
unsigned char r_buffer[rBUFFER_SIZE];

//串口相关对象
//boost::asio::io_service iosev;
//boost::asio::serial_port sp(iosev, "/dev/ttyUSB0");
//boost::system::error_code err;

/********************************************************
            串口发送接收相关常量、变量、共用体对象
********************************************************/
const unsigned char ender = {0x0D};
const unsigned char header = {0xAA};

//驱动模式
struct Control_Way
{
    unsigned char data[1];
} VelWay;

//发送左右轮速控制速度共用体,传感器的X，Z，Angle，用于数据转化
union sendData
{
    short d;//short是短整形、两字节，16位
    unsigned char data[2];//data[2]储存两个十六进制数，共16位。//所以两者可以转化
} leftVelSet, rightVelSet;

const double ROBOT_LENGTH = 0.85; // 两轮之间距离m
const double ROBOT_RADIUS = 0.10;  //  轮子半径m

/********************************************************
函数功能：串口参数初始化
入口参数：无
出口参数：
函数引用：robot.cpp中的bool robot::init(){}引用
********************************************************/
void serialInit()
{ 
    try
    {
        ser.setPort("/dev/ttyUSB0");
        // ser.setPort("/dev/ttyUSB0");　// 这个端口号就是之前用cutecom看到的端口名称
        ser.setBaudrate(115200);
        serial::Timeout to = serial::Timeout::simpleTimeout(1000);
        ser.setTimeout(to);
        ser.open();
    }
    catch (serial::IOException &e)
    {
        ROS_INFO_STREAM("Failed to open port");
        // return -1;
    }
    ROS_INFO_STREAM("Succeed to open port");
}

/********************************************************
函数功能：将机器人的线速度和角速度分解成左右轮子速度，打包发送给下位机
入口参数：参数来自于robot.cpp--robot:deal
出口参数：
********************************************************/
void writeSpeed(double RobotV, double YawRate, unsigned char StopFlag)
{
    unsigned char buf[8] = {0};//buf缓冲区与stm32上的数据对应，9个十六进制
    int i, length = 0;

    //计算左右轮期望速度
    if (RobotV == 0 && YawRate != 0) //旋转
    {
        leftVelSet.d = (short)(YawRate * ROBOT_RADIUS);//基础占空比是80
        rightVelSet.d = (short)(-YawRate * ROBOT_RADIUS);
    }
    
    if (RobotV != 0 && YawRate == 0) //直线
    {
        leftVelSet.d = (short)(RobotV); //下位机驱动器采用的是占空比调速
        rightVelSet.d = (short)(RobotV);//基础占空比是100
    }

    if (RobotV != 0 && YawRate != 0)//既有线速度，又有角速度
    {
        leftVelSet.d = (short)(RobotV+YawRate * ROBOT_RADIUS/2);//(short)( YawRate/30 * ((YawRate*1125)/(-RobotV*4655)+1.2));//简化运算后，将角速度转化成线速度取其一半为加权值
        rightVelSet.d = (short)(RobotV-YawRate * ROBOT_RADIUS/2);//(short)( YawRate/30 * ((YawRate*1125)/(-RobotV*4655)-1.2));// (short)(RobotV-YawRate * ROBOT_RADIUS/2);
    }

    if (RobotV == 0 && YawRate == 0)
    {
        leftVelSet.d = (short)(RobotV+YawRate);//无用的计算，结果是0
        rightVelSet.d = (short)(RobotV+YawRate);//无用的计算，结果是0
    }
  
    ROS_INFO("leftV: %d", leftVelSet.d);
    ROS_INFO("rightV: %d", rightVelSet.d);
    buf[0] = header;
    
    buf[1] = StopFlag;
    ROS_INFO("StopFlag: %x", StopFlag);
    
    if(buf[1] == 0x01)
    {
            for (i = 0; i < 2; i++)
       {
            buf[i + 2] = rightVelSet.data[1 - i]; // buf[2] buf[3]
            buf[i + 4] = leftVelSet.data[1 - i];  // buf[4] buf[5]
       }
    }
    else
    {
        buf[1]=0x02;
    }
    /* 试验的数据 */
    // buf[2]=0x00;
    // buf[3]=0xc8;
    // buf[4]=0x00;
    // buf[5]=0xc8;
    /* 如果在控制中出问题，将buf[6]设为校验值，进行一个简单的加法求和校验 */
    buf[6] = (buf[0]+buf[1]+buf[2]+buf[3]+buf[4]+buf[5]) & 0xFF;
    buf[7] = ender;
    
    /* 下发数据指令 */    
    /* write的声明：write (const uint8_t *data, size_t size); */
    ser.write(buf,sizeof(buf));

     ROS_INFO(" %x %x %x %x %x %x %x",buf[0],buf[1],buf[2],buf[3],buf[4],buf[5],buf[6]);
}


```

这段代码是用于机器人控制的ROS（Robot Operating System）节点的一部分，主要负责与下位机（例如微控制器或其他硬件）进行串行通信。它使用C++编写，并利用ROS和Boost库来实现。下面是对代码的详细解释：

### 头文件引用
- `#include "robot_bringup/mbot_linux_serial.h"`：引入串行通信的自定义头文件。
- `#include "string.h"`：标准C语言字符串处理库。
- `#include <boost/bind.hpp>`：引入Boost库的bind功能，用于函数和参数绑定。
- `#include "ros/ros.h"`：引入ROS的主要功能。
- `#include "std_msgs/String.h"`：引入ROS标准消息类型。
- `#include "serial/serial.h"`：引入串行通信库。

### 全局变量和定义
- `serial::Serial ser;`：定义一个`serial::Serial`对象用于串行通信。
- `sBUFFER_SIZE` 和 `rBUFFER_SIZE`：定义发送和接收缓冲区的大小。
- `s_buffer` 和 `r_buffer`：定义发送和接收缓冲区。
- `ROBOT_LENGTH` 和 `ROBOT_RADIUS`：定义机器人的尺寸参数。

### 串行通信初始化函数 `serialInit()`
- 初始化串行端口设置（如端口号、波特率、超时）。
- 尝试打开串行端口，如果失败则记录日志。

### 速度写入函数 `writeSpeed()`
- 此函数根据输入的线速度`RobotV`和角速度`YawRate`以及停止标志`StopFlag`，计算左右轮的速度，并通过串行端口发送给下位机。
- 计算左右轮速度时，考虑了不同的运动情况（如旋转、直线运动、同时具有线速度和角速度）。
- 使用共用体`sendData`将速度值转换为字节数据，以便于串行通信。
- 数据包的格式包括头部、速度数据、校验和结束符。
- 使用`ser.write()`函数发送数据。

### 总结

此代码的主要功能是通过串行通信将机器人的运动指令（线速度和角速度）发送到下位机。它处理了不同的运动情况，并将速度指令转换为适合串行通信的格式。这是机器人控制系统中一个重要的部分，负责与硬件层面的通信和控制。

## joy_control.cpp

```c++
//#include "robot_bringup/robot.h"
//#include <dynamic_reconfigure/server.h>
#include "ros/ros.h"
//#include "mbot_linux_serial.h"
#include <geometry_msgs/Twist.h>
#include <sensor_msgs/Joy.h>

int i=100; 

class JoyControl
{
private:
    // 处理手柄发送过来的信息
    void callback(const sensor_msgs::Joy::ConstPtr &joy);
    // 实例化ROS句柄
    ros::NodeHandle nh;
    // 定义订阅者对象，用来订阅手柄发送的数据
    ros::Subscriber sub;
    // 定义发布者对象，用来将手柄数据发布到乌龟控制话题上
    ros::Publisher pub;
    // 用来接收launch文件中设置的参数，绑定手柄摇杆、轴的映射
    int axis_linear, axis_angular;
    //用于接收joy参数的基础值：axis_linear,axis_angular,bu
    float firstdata[2];
    float finaldate[2];

public:
    JoyControl();
};

JoyControl::JoyControl()
{
    // 从参数服务器读取的参数
    nh.param<int>("axis_linear", axis_linear, 1);
    nh.param<int>("axis_angular", axis_angular, 3);
 
    pub = nh.advertise<geometry_msgs::Twist>("cmd_vel", 1);
    sub = nh.subscribe<sensor_msgs::Joy>("joy", 10, &JoyControl::callback, this);

}

void JoyControl::callback(const sensor_msgs::Joy::ConstPtr &joy)
{
    geometry_msgs::Twist v;
    /* 将手柄摇杆轴拨动时值的输出赋值的线速度和角速度，在这个地方可用参数服务器，也可不用 */
    // basedata[0]=joy->axes[1];
    // basedata[1]=joy->axes[3];
    firstdata[0]=joy->axes[axis_linear];
    firstdata[1]=joy->axes[axis_angular];
    /* buttons就不用参数服务器了 */
    //basedata[2]=joy->buttons[5];
    //basedata[3]=joy->buttons[6];

    /* 按键左加右减，以百分比的形式计算 */
    if(joy->buttons[4]==1)//增加
    {
        i=i+10;
    }
    if(joy->buttons[5]==1)//减小
    {
        i=i-10;
    }
    finaldate[0]=firstdata[0]*i*0.01;
    finaldate[1]=firstdata[1]*i*0.01;

    v.linear.x = finaldate[0]/4;
    v.angular.z = finaldate[1]/2;

    ROS_INFO("线速度:%.3lf ; 角速度:%.3lf", v.linear.x, v.angular.z);
    pub.publish(v);
}

int main(int argc, char **argv)
{
    // 设置编码
    setlocale(LC_ALL, "");
    // 初始化ROS节点
    ros::init(argc, argv, "joy_control");
    //在JoyControl这个前面不能加东西
    JoyControl joycontrol;

    ros::Rate loop_rate(10);

    ros::spin(); 
    return 0;
}


```

这段代码定义了一个用于处理游戏手柄输入的ROS（Robot Operating System）节点，用C++编写。它监听来自游戏手柄的消息，并根据这些消息控制机器人的线速度和角速度。代码的主要部分包括一个`JoyControl`类和主函数。下面是对代码的详细解释：

### 类 `JoyControl`
- **私有成员**:
  - `void callback(const sensor_msgs::Joy::ConstPtr &joy)`: 一个回调函数，用于处理从手柄接收的消息。
  - `ros::NodeHandle nh`: ROS节点句柄，用于与ROS通信。
  - `ros::Subscriber sub`: 订阅者对象，订阅手柄的数据。
  - `ros::Publisher pub`: 发布者对象，将手柄数据发布到控制话题上。
  - `int axis_linear, axis_angular`: 从参数服务器获取的参数，用于映射手柄的线性和角速度轴。
  - `float firstdata[2], finaldate[2]`: 用于存储处理后的手柄数据。

- **公共成员**:
  - `JoyControl()`: 构造函数，用于初始化类的成员。

### 构造函数 `JoyControl::JoyControl()`
- 从参数服务器读取`axis_linear`和`axis_angular`参数。
- 初始化发布者对象`pub`，用于发布到`cmd_vel`话题。
- 初始化订阅者对象`sub`，用于订阅`joy`话题，并绑定回调函数`callback`。

### 回调函数 `JoyControl::callback()`
- 获取手柄的轴数据，并根据参数映射进行处理。
- 通过手柄按钮控制速度增减，速度调整使用变量`i`。
- 根据处理后的手柄数据设置机器人的线速度（`v.linear.x`）和角速度（`v.angular.z`）。
- 打印线速度和角速度的信息，并发布到`cmd_vel`话题。

### 主函数 `int main(int argc, char **argv)`
- 初始化ROS节点。
- 创建`JoyControl`类的实例`joycontrol`。
- 设置循环率并进入ROS消息处理循环（`ros::spin()`）。

### 总结
此代码创建了一个ROS节点，该节点订阅游戏手柄的输入并根据这些输入来控制机器人。通过调整手柄的按钮和摇杆，可以动态调整机器人的速度。这样的节点非常适合于对机器人进行远程手动控制，例如在实验室测试或演示中。

## robot_bringup.launch

```html
<launch>

    <!-- 启动mbot -->
    <node pkg="robot_bringup" type="robot_bringup" name="robot_bringup" output="screen" >
        <!-- 参数可以直接在launch文件中通过param设置，也可以用yaml文件传参，以下就是直接在launch文件中设置 -->
        <param name="speedparam_x" value="1125/2"/> <!-- 线速度的速度系数 -->
        <param name="speedparam_y" value="4655/2"/> <!-- 角速度的速度系数 -->
        <rosparam file="$(find robot_bringup)/param/speedparam.yaml" command="load"/>
    </node>

    <!-- 手柄控制 -->
    <!-- <node pkg="joy" type="joy_node" name="joy_node" /> -->

    <!--与cmake里面的add_executable有关-->
    <!-- <node pkg="joy_control" type="joy_control" name="joy_control" > 
        <param name="axis_linear" value="1" type="int" />
        <param name="axis_angular" value="3" type="int" />
    </node> -->

    <node pkg="rqt_reconfigure" type="rqt_reconfigure" name="rqt_reconfigure" />
</launch>
```

这段代码是一个ROS（Robot Operating System）的launch文件，用于同时启动多个ROS节点并设置相关参数。Launch文件是ROS中用于启动和管理多个节点的一个重要工具，它使用XML格式。以下是对这个launch文件中每个部分的详细解释：

### 节点启动
1. **启动`robot_bringup`节点**:
   - `<node pkg="robot_bringup" type="robot_bringup" name="robot_bringup" output="screen">`：这一行定义了一个节点，它指定了要启动的包（`pkg="robot_bringup"`），节点类型（`type="robot_bringup"`），节点名称（`name="robot_bringup"`），以及节点输出应该显示在屏幕上（`output="screen"`）。
   - `<param name="speedparam_x" value="1125/2"/>` 和 `<param name="speedparam_y" value="4655/2"/>`：这两行设置了名为`speedparam_x`和`speedparam_y`的参数，它们似乎用于配置机器人的线速度和角速度系数。
   - `<rosparam file="$(find robot_bringup)/param/speedparam.yaml" command="load"/>`：这行加载了一个YAML格式的参数文件，用于设置或覆盖其他参数。`$(find robot_bringup)`是一个ROS变量，它会被替换为`robot_bringup`包的路径。

### 注释掉的节点
以下节点在文件中被注释掉了，意味着它们不会被启动，但保留在文件中以供将来可能的使用：
- **手柄控制节点** (`joy_node`)：用于将手柄的输入转换为ROS消息。
- **`joy_control`节点**：一个自定义节点，可能用于处理`joy_node`发送的消息并控制机器人。

### RQT重配置节点
- `<node pkg="rqt_reconfigure" type="rqt_reconfigure" name="rqt_reconfigure" />`：这一行启动了`rqt_reconfigure`节点，它是一个ROS工具，允许用户通过图形界面动态地重新配置运行中节点的参数。

### 总结
这个launch文件配置了一个或多个ROS节点的启动和参数设置。它主要用于启动`robot_bringup`节点，同时设置了一些速度参数，并加载了一个参数文件。此外，它还提供了手柄控制节点和自定义的`joy_control`节点的可选启动配置，以及启动了`rqt_reconfigure`以便于动态调整参数。这种文件在复杂的ROS系统中非常有用，因为它可以简化节点的启动和管理过程。

## joy_control.launch

```html
<launch>
    <!-- 手柄控制 -->
    <node pkg="joy" type="joy_node" name="joy_node" />

    <!-- 与cmake里面的add_executable有关 -->
    <node pkg="robot_bringup" type="joy_control" name="joy_control" output="screen"> 
        <!-- 给axis_linear参数赋值 -->
        <param name="axis_linear" value="1" type="int" />
        <param name="axis_angular" value="3" type="int" />
    </node>

</launch> 
```

这个ROS（Robot Operating System）的launch文件用于启动两个ROS节点，一个是用于手柄控制的`joy_node`，另一个是`joy_control`节点，可能用于将手柄输入转换成机器人的控制命令。以下是对这个launch文件中每个部分的详细解释：

### 手柄控制节点
- `<node pkg="joy" type="joy_node" name="joy_node" />`：这一行启动了一个名为`joy_node`的节点。它指定了所属的包为`joy`，节点类型为`joy_node`。此节点通常用于从连接到计算机的游戏手柄接收输入，并将这些输入转换为ROS消息。这使得可以使用物理手柄来控制机器人或其他ROS驱动的设备。

### 自定义控制节点
- `<node pkg="robot_bringup" type="joy_control" name="joy_control" output="screen">`：这一行定义了一个名为`joy_control`的节点，它指定了所属的包为`robot_bringup`，节点类型为`joy_control`。`output="screen"`表明节点的输出会显示在屏幕上。这个节点可能是一个自定义的ROS节点，用于处理来自`joy_node`的消息，并将其转换为控制机器人的命令。

### 参数设置
- `<param name="axis_linear" value="1" type="int" />`
- `<param name="axis_angular" value="3" type="int" />`
  这两行为`joy_control`节点设置了两个参数：`axis_linear`和`axis_angular`。这些参数可能用于指定手柄上哪些轴用于控制机器人的线性和角速度。这里，`axis_linear`被设置为1，`axis_angular`被设置为3，这些值通常对应于手柄上的特定摇杆或按钮。

### 总结
此launch文件用于启动与手柄控制相关的两个ROS节点。第一个节点是标准的`joy_node`，用于从物理手柄接收输入。第二个节点是`joy_control`，它可能是一个自定义的节点，用于将`joy_node`的输出转换为机器人控制命令。通过在launch文件中设置参数，用户可以自定义手柄的控制行为，例如指定哪些手柄按钮或摇杆控制机器人的不同运动方向和速度。这种配置非常适用于需要手动控制机器人的场景，如实验、演示或游戏。

## CMakeList.txt

```cmake
cmake_minimum_required(VERSION 2.8.3)
project(robot_bringup)



find_package(catkin REQUIRED COMPONENTS
  dynamic_reconfigure
  geometry_msgs
  roscpp
  rospy
  sensor_msgs
  tf
  serial
  std_msgs
  message_generation
  nav_msgs
)

generate_dynamic_reconfigure_options(
  cfg/speedparam.cfg
)

catkin_package(
   INCLUDE_DIRS include
)

include_directories(
  include
  ${catkin_INCLUDE_DIRS}

)
########
#三个cpp文件一起运行，只能存在一个main函数，相当于把多个函数放在不同的cpp文件中
########
add_executable(robot_bringup  
               src/robot_bringup.cpp
               src/robot.cpp
               src/mbot_linux_serial.cpp
	       )
##########
#两个main函数不能共存，要用不同的add_executable
##########
add_executable(joy_control src/joy_control.cpp)


add_dependencies(${PROJECT_NAME} ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})
      
target_link_libraries(robot_bringup ${catkin_LIBRARIES})
target_link_libraries(joy_control ${catkin_LIBRARIES})





```

这段代码是一个用于ROS（Robot Operating System）项目的CMake配置文件。CMake是一个跨平台的自动化构建工具，它使用CMakeLists.txt文件来指定如何编译和链接程序。在ROS项目中，CMake用于定义如何构建各种节点和库。以下是对这个CMake配置文件的每个部分的详细解释：

### 基本配置
- `cmake_minimum_required(VERSION 2.8.3)`: 指定了CMake的最低版本要求。
- `project(robot_bringup)`: 定义了项目名称为`robot_bringup`。

### 寻找依赖包
- `find_package(catkin REQUIRED COMPONENTS ...)`: 寻找并加载catkin和其他必需的ROS组件。这些组件包括`dynamic_reconfigure`, `geometry_msgs`, `roscpp`, `rospy`, `sensor_msgs`, `tf`, `serial`, `std_msgs`, `message_generation`, `nav_msgs`等。

### 动态重配置
- `generate_dynamic_reconfigure_options(cfg/speedparam.cfg)`: 生成动态重配置选项。这通常用于创建可以在运行时改变的参数，这里指定的配置文件是`cfg/speedparam.cfg`。

### Catkin包配置
- `catkin_package(INCLUDE_DIRS include)`: 定义catkin包。`INCLUDE_DIRS include`指明包含的目录是`include`。

### 包含的目录
- `include_directories(include ${catkin_INCLUDE_DIRS})`: 指定了项目包含的头文件目录。这包括了项目内的`include`目录和由`find_package`找到的catkin组件的头文件目录。

### 添加可执行文件
- `add_executable(robot_bringup src/robot_bringup.cpp src/robot.cpp src/mbot_linux_serial.cpp)`: 创建一个名为`robot_bringup`的可执行文件，它包含了`src/robot_bringup.cpp`, `src/robot.cpp`, `src/mbot_linux_serial.cpp`这三个源文件。这里说明了这三个源文件中只能存在一个`main`函数。

- `add_executable(joy_control src/joy_control.cpp)`: 创建另一个名为`joy_control`的可执行文件，它包含了`src/joy_control.cpp`源文件。这表明`joy_control.cpp`是一个独立的程序，拥有自己的`main`函数。

### 添加依赖
- `add_dependencies(${PROJECT_NAME} ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})`: 确保在编译当前项目之前，所有指定的依赖项目都已被构建。

### 链接库
- `target_link_libraries(robot_bringup ${catkin_LIBRARIES})`
- `target_link_libraries(joy_control ${catkin_LIBRARIES})`
  这两行指定了构建`robot_bringup`和`joy_control`可执行文件时需要链接的库。这里链接的是catkin的库。

### 总结
此CMake配置文件用于构建ROS项目`robot_bringup`，它定义了如何查找依赖、生成动态重配置选项、编译源代码，并链接所需的库。此文件中定义了两个可执行文件`robot_bringup`和`joy_control`，分别对应于项目中的不同功能模块。

## 杂

### 命名空间

命名空间（Namespace）是一种在C++和其他编程语言中用于组织和管理名称的机制，主要用于防止名称冲突。它允许开发者将变量、函数、类等代码实体组织在一个独立的名字下，避免与其他部分的代码中的同名实体发生冲突。以下是关于命名空间的一些详细解释：

#### 定义

- **创建命名空间**：使用关键字`namespace` followed by the namespace name and a block of code in curly braces `{ ... }`。
  
  ```cpp
  namespace myNamespace {
      int myFunction() {
          // 函数实现
      }
  }
  ```

#### 使用

- **访问命名空间中的实体**：可以使用命名空间名称加作用域解析运算符（`::`）来访问其内的实体。
  ```cpp
  int x = myNamespace::myFunction();
  ```

- **`using`声明**：可以使用`using`声明来引入命名空间中的特定成员，这样就可以不用每次都输入完整的命名空间。
  
  ```cpp
  using myNamespace::myFunction;
  myFunction(); // 直接调用
  ```
  
- **`using`指令**：可以使用`using namespace`来引入整个命名空间，从而可以直接使用其内的所有实体，但这样可能会引起名称冲突，应谨慎使用。
  ```cpp
  using namespace myNamespace;
  myFunction(); // 直接调用
  ```

#### 好处

- **避免名称冲突**：在大型项目中或在使用多个库时，命名空间可以有效地防止不同模块或库中相同名称的函数、变量等产生冲突。
- **提高代码可读性**：通过逻辑上的分组，命名空间可以提高代码的组织性和可读性。

#### 注意事项

- **全局命名空间**：不在任何命名空间中的实体属于全局命名空间。
- **嵌套命名空间**：命名空间可以嵌套，即一个命名空间内可以定义另一个命名空间。
- **匿名命名空间**：没有名称的命名空间被称为匿名命名空间，其中的实体在其定义的文件内是局部的。
- **使用`using`的风险**：过度使用`using namespace`可能会导致名称冲突和代码可读性降低。

#### 示例

```cpp
namespace geometry {
    class Point {
        // 类定义
    };
}

// 使用
geometry::Point point;
```

在这个示例中，`Point`类被定义在`geometry`命名空间中，避免了与其他可能的`Point`类冲突。

### 析构函数

析构函数是一个特殊的类成员函数，在C++中用于管理一个对象生命周期结束时的清理工作。当一个对象的生命周期结束时（例如，当它离开其作用域或被删除时），该对象的析构函数被自动调用。以下是关于析构函数的更详细的解释：

#### 基本特征

1. **命名**：析构函数的名称由类名前加上波浪号（`~`）构成。例如，如果类名为`MyClass`，则其析构函数命名为`~MyClass()`。
2. **自动调用**：当对象生命周期结束时（例如，局部对象的函数返回时，或当使用`delete`删除动态分配的对象时），其析构函数自动被调用。
3. **无返回值**：析构函数没有返回类型，也不能返回值。
4. **无参数**：析构函数不能带有参数，因此每个类只能有一个析构函数。
5. **非强制性**：如果未为类显式定义析构函数，编译器会自动生成一个默认的析构函数。

#### 作用

- **资源释放**：析构函数主要用于在对象生命周期结束时释放资源和进行清理。例如，释放动态分配的内存、关闭文件、断开网络连接等。
- **清理操作**：执行任何必要的最终清理工作，如关闭日志、通知其他对象等。

#### 继承中的析构函数

- 在类继承中，析构函数的行为与构造函数相反。当派生类对象被销毁时，首先调用派生类的析构函数，然后调用其基类的析构函数。
- 如果基类的析构函数是虚函数（使用`virtual`关键字声明），则在通过基类指针或引用删除派生类对象时，可以确保调用适当的析构函数，这对于多态非常重要。

#### 示例

```cpp
class MyClass {
public:
    MyClass() {
        // 构造函数
    }
    ~MyClass() {
        // 析构函数，进行资源释放和清理工作
    }
};
```

在这个示例中，`MyClass`的实例在不再使用时会自动调用其析构函数`~MyClass()`。如果类中有动态分配的资源或需要特殊的清理操作，应在析构函数中进行处理。

#### 注意事项

- 在管理资源时，遵循“资源获取即初始化”（RAII）原则，即在构造函数中获取资源，在析构函数中释放资源，这是C++中管理资源的一种有效方法。
- 避免在析构函数中抛出异常，因为这可能导致程序终止。如果析构函数中的操作可能抛出异常，应该在析构函数内部捕获并处理这些异常，而不是让它们传播到外部。

### 构造函数

构造函数是一个在类中定义的特殊函数，它在创建类的对象时自动调用。它主要用于初始化对象的属性和执行一些在对象创建时必须进行的步骤。构造函数在C++和其他面向对象编程语言中非常重要，下面是对构造函数的详细解释：

#### 基本特征
1. #### **名称**：构造函数的名称与类名相同。
2. **自动调用**：当类的实例被创建时，其构造函数会被自动调用。
3. **无返回类型**：构造函数不具有返回类型，甚至不是`void`。
4. **重载**：构造函数可以被重载，意味着可以有多个具有不同参数列表的构造函数。
5. **默认构造函数**：如果未显式定义任何构造函数，编译器将提供一个无参数的默认构造函数。

#### 作用

- **初始化对象**：构造函数最主要的作用是初始化对象的成员变量。可以直接在构造函数体中初始化，或使用初始化列表。
- **执行必要操作**：在对象创建时，可能需要执行某些操作，如分配资源、设置初始状态等，这些都可以在构造函数中完成。

#### 类型

- **无参构造函数**：不接受任何参数，用于创建默认形式的对象。
- **有参构造函数**：接受一个或多个参数，用于根据提供的参数创建对象。
- **复制构造函数**：接受同类的另一个对象作为参数，用于创建一个新对象作为原有对象的副本。
- **移动构造函数**（C++11及以后）：接受同类对象的右值引用作为参数，用于支持移动语义，从而提高性能。

#### 示例

```cpp
class MyClass {
public:
    // 无参构造函数
    MyClass() {
        // 初始化代码
    }

    // 有参构造函数
    MyClass(int value) {
        // 根据value初始化对象
    }

    // 复制构造函数
    MyClass(const MyClass& other) {
        // 根据other对象来初始化新对象
    }
};
```

#### 注意事项

- **初始化顺序**：类成员的初始化顺序与它们在类中声明的顺序相同，而不是在构造函数初始化列表中出现的顺序。
- **默认构造函数**：如果类中定义了至少一个构造函数，编译器不会自动生成默认构造函数。
- **委托构造函数**（C++11及以后）：一个构造函数可以调用同一类中的另一个构造函数，这称为委托构造。

构造函数是面向对象编程的一个核心概念，正确理解和使用构造函数对于设计健壮和有效的类至关重要。

### 预处理指令

预处理指令是C和C++语言中的一种特殊指令，用于在编译之前对源代码进行某些处理。这些指令以井号（`#`）开头，并通常位于源文件的顶部。预处理指令不是程序语句，因此不会被编译器转换为机器代码。它们在编译过程的预处理阶段被处理。以下是一些常用预处理指令的详细解释：

#### `#include`

- 用于包含头文件，将指定文件的内容插入到当前位置。
- 例如：`#include <iostream>` 或 `#include "myheader.h"`

#### `#define`

- 用于定义宏，宏是预处理器的简单替换工具。
- 例如：`#define PI 3.14159`

#### `#undef`

- 用于取消已定义的宏。
- 例如：`#undef PI`

#### `#ifdef` 和 `#ifndef`

- `#ifdef` 检查宏是否被定义，如果是，则执行随后的代码。
- `#ifndef` 检查宏是否未被定义，如果未定义，则执行随后的代码。
- 通常用于条件编译，如防止头文件被多次包含。
- 例如：
  ```cpp
  #ifndef MYHEADER_H
  #define MYHEADER_H
  // 头文件内容
  #endif
  ```

#### `#if`、`#else`、`#elif` 和 `#endif`

- 用于更复杂的条件编译。
- `#if` 后跟一个条件，如果条件为真，则编译随后的代码。
- `#else` 和 `#elif` 用于指定替代条件。
- `#endif` 表示条件编译块的结束。
- 例如：
  ```cpp
  #if defined(DEBUG)
  // 调试代码
  #else
  // 非调试代码
  #endif
  ```

#### `#error`

- 当预处理器遇到`#error`指令时，会生成一个错误，并停止编译过程。
- 用于在代码不应该被编译的情况下发出错误。
- 例如：`#error "不支持的平台"`

#### `#pragma`

- 提供了一种实现特定的编译器指令的方法，不同编译器可能有不同的`#pragma`指令。
- 例如：`#pragma once`（确保头文件只被包含一次）

#### 预处理器的操作特点

- 预处理器在编译器处理源代码之前运行。
- 它仅对文本进行操作，不了解C或C++的语法。
- 预处理指令可以极大地影响代码的编译方式。

预处理器是C和C++编程中的一个强大工具，可以用于条件编译、防止头文件的多重包含、定义编译时常数等。正确使用预处理器可以使代码更加模块化、易于管理和跨平台兼容。不过，不当使用预处理器也可能导致代码难以阅读和维护。

### 回调函数

回调函数是一种在编程中广泛使用的概念，它允许将一个函数作为参数传递给另一个函数，并在适当的时候被调用。这是一种实现异步编程和事件驱动编程的常用技术。以下是对回调函数的详细解释：

#### 基本概念

- **函数指针**：在C和C++中，回调函数通常是通过函数指针实现的。函数指针指向一个函数的地址，允许在运行时调用该函数。
- **高阶函数**：能够接受其他函数作为参数或返回一个函数的函数称为高阶函数。在使用回调函数时，通常涉及高阶函数的使用。

#### 使用场景

- **异步操作**：在进行异步编程时，例如文件读取、网络请求或定时操作，回调函数在操作完成后被调用，用于处理结果或继续执行后续代码。
- **事件监听**：在事件驱动的编程模型中，如GUI编程或Web开发，回调函数用于响应特定的事件，如用户点击或键盘输入。
- **自定义操作**：在某些函数中，允许用户通过回调函数自定义特定的操作或行为。

#### 示例
假设有一个简单的C++例子，展示了如何使用回调函数：

```cpp
#include <iostream>
using namespace std;

// 回调函数示例
void greet(void (*callbackFunc)(string)) {
    cout << "Hello, ";
    callbackFunc("World");
}

// 具体的回调函数
void sayName(string name) {
    cout << name << endl;
}

int main() {
    greet(sayName);
    return 0;
}
```

在这个例子中，`greet`函数接受一个回调函数`callbackFunc`作为参数。在`main`函数中，`greet`被调用，并传入了`sayName`作为其回调函数。

#### 注意事项

- **函数签名**：回调函数需要与其预期的函数指针签名相匹配。这意味着返回类型和参数类型必须一致。
- **生命周期管理**：确保回调函数在被调用时是有效的，尤其是在涉及异步操作时。
- **可读性和维护性**：过度使用回调可能导致所谓的“回调地狱”，使代码难以理解和维护。

回调函数是一种强大的编程技术，允许更灵活的代码结构和异步处理。在现代编程中，特别是在JavaScript等语言中，它们非常常见。然而，随着Promise和async/await等现代异步编程模式的出现，回调函数在某些场景中正逐渐被新模式所取代。

### ROS参数服务器

ROS（Robot Operating System）参数服务器是ROS中一个重要的特性，用于存储和管理节点运行时的配置参数。它允许不同的节点在运行时共享和修改参数，从而提供了一种灵活的方式来调整节点的行为。以下是对ROS参数服务器的详细解释：

#### 功能
- **参数存储和检索**：参数服务器允许节点在运行时存储和检索参数，如整数、浮点数、字符串、布尔值等。
- **多节点共享**：不同节点可以访问和修改存储在参数服务器上的参数，实现数据共享和动态配置。
- **运行时配置**：通过参数服务器，可以在不重启节点的情况下动态地调整节点配置。

#### 使用场景
- **全局和私有参数**：参数服务器可以存储全局参数（所有节点可见）和私有参数（仅特定节点可见）。
- **动态配置**：在运行时调整算法参数、调试信息等，特别适用于需要根据环境或情况变化进行调整的场景。
- **节点初始化**：在节点启动时读取配置参数，如端口号、话题名称、行为阈值等。

#### 访问和设置参数

- **设置参数**：节点可以通过ROS API向参数服务器设置参数值。
- **获取参数**：节点可以查询参数服务器获取参数值。如果请求的参数不存在，通常可以指定一个默认值。
- **命名空间**：参数可以在不同的命名空间中设置和获取，支持参数的组织和隔离。

#### API示例

- **C++**：
  ```cpp
  ros::NodeHandle nh;
  int my_param;
  nh.param("my_param", my_param, 42); // 获取参数，若不存在则默认为42
  nh.setParam("my_param", 24); // 设置参数
  ```
- **Python**：
  ```python
  import rospy
  my_param = rospy.get_param("my_param", 42) # 获取参数，若不存在则默认为42
  rospy.set_param("my_param", 24) # 设置参数
  ```

#### 注意事项

- **性能考虑**：频繁地访问参数服务器可能会影响性能，尤其是在网络延迟较大的情况下。
- **参数持久化**：参数服务器中的参数在ROS系统关闭后不会持久化保存。如果需要持久化参数，应考虑将参数存储在文件中。
- **安全性**：所有节点都可以访问和修改参数服务器中的参数，因此需要注意参数的安全性和正确性。

ROS参数服务器提供了一种高效、灵活的方式来管理和共享配置数据，是ROS中进行参数管理的重要工具。

### 动态重配置服务器

动态重配置服务器（Dynamic Reconfigure Server）是ROS（Robot Operating System）中的一个功能，允许在运行时动态地调整节点的配置参数。这意味着你可以在不重启节点的情况下改变其行为。以下是对动态重配置服务器的详细解释：

#### 功能和用途

- **动态参数调整**：动态重配置服务器允许用户在运行时改变ROS节点的参数，如调整速度、改变阈值、切换算法等。
- **GUI工具集成**：通常与rqt_reconfigure等图形用户界面工具集成，提供了一个友好的界面用于调整参数。
- **适应性**：使得ROS节点能够根据环境变化或用户输入动态调整其行为，提高了系统的适应性和灵活性。

#### 工作原理

- **配置文件**：首先需要定义一个配置文件（通常是`.cfg`文件），在其中列出所有可以动态调整的参数及其类型、范围和默认值。
- **服务器初始化**：在节点代码中创建一个动态重配置服务器，并指定它将使用的配置类型。
- **回调函数**：定义一个回调函数，当参数被修改时该函数将被调用。这个函数通常会更新内部变量，应用新的配置值。
- **客户端请求**：通过GUI工具或命令行工具发送参数修改请求到服务器，服务器接收请求并触发回调函数。

#### 示例代码

```cpp
#include <dynamic_reconfigure/server.h>
#include <package_name/ConfigType.h>

void callback(package_name::ConfigType &config, uint32_t level) {
    // 更新节点的配置，如config.speed, config.angle等
}

int main(int argc, char **argv) {
    ros::init(argc, argv, "node_name");

    dynamic_reconfigure::Server<package_name::ConfigType> server;
    server.setCallback(boost::bind(&callback, _1, _2));

    ros::spin();
    return 0;
}
```

#### 注意事项

- **线程安全**：由于回调函数可能在不同的线程中被调用，因此在更新共享变量时需要确保线程安全。
- **性能影响**：频繁地修改参数可能会对节点性能造成影响，尤其是在处理复杂任务时。
- **参数验证**：在回调函数中应验证参数值的有效性，以防止非法或不合理的配置。

总之，动态重配置服务器是ROS中一个强大的功能，它提供了在运行时调整节点配置的能力，使得系统能够更加灵活地适应不同的需求和条件。

### 动态重配置客户端

在ROS（Robot Operating System）中，动态重配置客户端是与动态重配置服务器互动的一部分，允许用户在运行时动态更改节点的配置参数。以下是对动态重配置客户端的详细解释：

#### 功能和用途

- **参数调整**：动态重配置客户端允许用户在ROS节点运行时调整其参数，如调节速度、改变算法设置等。
- **实时更新**：它使得能夠在不重启ROS节点的情况下实时更新配置，提高了系统的灵活性和适应性。
- **界面交互**：客户端通常提供图形化界面（如rqt_reconfigure）或命令行界面，使用户可以方便地更改参数。

#### 工作原理

- **与服务器通信**：动态重配置客户端通过ROS的通信机制与动态重配置服务器交互，请求参数更改。
- **触发回调**：当参数更改请求被发送到服务器时，服务器上的回调函数被触发，从而更新节点的运行参数。
- **反馈显示**：客户端会显示当前的参数设置，并在这些参数被更改后显示更新后的值。

#### 客户端类型

1. **命令行客户端**：`rosrun dynamic_reconfigure dynparam` 命令可以用于命令行环境中调整参数。例如：
   ```bash
   rosrun dynamic_reconfigure dynparam set [node_name] [param_name] [new_value]
   ```
   这种方法适用于脚本化或自动化的参数调整。

2. **图形化客户端**：`rqt_reconfigure` 提供了一个图形化界面，使得用户可以通过滑块、文本框等控件调整参数。它适用于需要直观反馈和易于操作界面的情况。

#### 使用场景

- **调试和测试**：在开发和测试阶段，可以使用动态重配置客户端来实验不同的参数设置，以观察它们对系统行为的影响。
- **实时调整**：在机器人或其他自动化系统的实际运行中，根据环境变化或特定需求调整参数。

#### 注意事项

- **节点支持**：只有实现了动态重配置服务器的ROS节点才能通过客户端进行动态重配置。
- **参数验证**：应在服务器端的回调函数中验证新参数的有效性，防止设置不合理的值。
- **性能考虑**：频繁的参数调整可能会影响节点性能，特别是在处理复杂任务时。

总之，动态重配置客户端是ROS中一个重要的工具，它为实时调整节点参数提供了方便的途径，是实现灵活、可调节的ROS系统的关键部分。

# 履带车下位机

## motor.c

```c
#include "./bsp_motor/motor.h"

s8 ControlMoterData1[8];
s8 ControlMoterData2[8];
s8 ControlMoterData3[8];

 /**
  * @brief  电机控制  Set_Left_Mode|Set_Right_Mode
  * @param  无
  * @retval 两个电机的线速度分别控制
  */

void Set_Left_Mode(uint32_t ID1,s8 Target_L_Speed_High,s8 Target_L_Speed_Low)
{	
	/* 第一个包，配置电机控制类型 *****************/
	ControlMoterData1[0]=0x2f;
	ControlMoterData1[1]=0x00;
	ControlMoterData1[2]=0x20;
	ControlMoterData1[3]=0x00;
	/* 表示电机控制类型 */	
	ControlMoterData1[4]=0x00;//占空比调速
	ControlMoterData1[5]=0x00;
	ControlMoterData1[6]=0x00;
	ControlMoterData1[7]=0x00;
	CAN_SendMsg(ID1, ControlMoterData1);
	
//	/* 第二个包，开启电机速度单位为转速 *****************/
//	ControlMoterData2[0]=0x2f;
//	ControlMoterData2[1]=0x0A;
//	ControlMoterData2[2]=0x20;
//	ControlMoterData2[3]=0x00;
//	/* 表示电机速度单位：RPM*/
//	ControlMoterData2[4]=0x01;
//	ControlMoterData2[5]=0x00;
//	ControlMoterData2[6]=0x00;
//	ControlMoterData2[7]=0x00;
//	CAN_SendMsg(ID1,ControlMoterData2);

	/* 第三个包，配置电机控制量 *****************/
	ControlMoterData3[0]=0x2b;
	ControlMoterData3[1]=0x01;
	ControlMoterData3[2]=0x20;//0x20是高位//0x01是低位//合起来是0x2001
	ControlMoterData3[3]=0x00;
	/* 表示电机控制量：转速，-500~500RPM，(s32)0xFE0C ~ 0x01F4*/
	ControlMoterData3[4]=Target_L_Speed_Low;//0x0C低位在低字节  -500RPM
	ControlMoterData3[5]=Target_L_Speed_High;//0xFE高位在高字节//代表的速度是0xFE0C
	ControlMoterData3[6]=0x00;
	ControlMoterData3[7]=0x00;
	CAN_SendMsg(ID1,ControlMoterData3);
	
}	


void Set_Right_Mode(uint32_t ID2,s8 Target_R_Speed_High,s8 Target_R_Speed_Low)
{
		//缺一个函数将target_speed转化为二进制
	//u8 checkbit=0;//设置校验位
	
	/* 第一个包，配置电机控制类型 *****************/
	ControlMoterData1[0]=0x2f;
	ControlMoterData1[1]=0x00;
	ControlMoterData1[2]=0x20;
	ControlMoterData1[3]=0x00;
	/* 表示电机控制类型 */	
	ControlMoterData1[4]=0x00;//占空比控制
	ControlMoterData1[5]=0x00;
	ControlMoterData1[6]=0x00;
	ControlMoterData1[7]=0x00;
	CAN_SendMsg(ID2, ControlMoterData1);
	
//	/* 第二个包，开启电机速度单位为转速 *****************/
//	ControlMoterData2[0]=0x2f;
//	ControlMoterData2[1]=0x0A;
//	ControlMoterData2[2]=0x20;
//	ControlMoterData2[3]=0x00;
//	/* 表示电机速度单位：RPM*/
//	ControlMoterData2[4]=0x01;
//	ControlMoterData2[5]=0x00;
//	ControlMoterData2[6]=0x00;
//	ControlMoterData2[7]=0x00;
//	CAN_SendMsg(ID2,ControlMoterData2);

	/* 第三个包，配置电机控制量 *****************/
	ControlMoterData3[0]=0x2b;
	ControlMoterData3[1]=0x01;
	ControlMoterData3[2]=0x20;//0x20是高位//0x01是低位//合起来是0x2001
	ControlMoterData3[3]=0x00;
	/* 表示电机控制量：转速，-500~500RPM，(s32)0xFE0C ~ 0x01F4*/
	ControlMoterData3[4]=Target_R_Speed_Low;//0x0C低位在低字节
	ControlMoterData3[5]=Target_R_Speed_High;//0xFE高位在高字节//代表的速度是0xFE0C
	ControlMoterData3[6]=0x00;
	ControlMoterData3[7]=0x00;
	CAN_SendMsg(ID2,ControlMoterData3);
	


}	

void Set_Stop(uint32_t ID3)
{
	
	/* 停止包结构 *****************/
	ControlMoterData1[0]=0x2f;
	ControlMoterData1[1]=0x00;
	ControlMoterData1[2]=0x20;
	ControlMoterData1[3]=0x00;
	/* 表示电机控制类型 */	
	ControlMoterData1[4]=0x10;//停止
	ControlMoterData1[5]=0x00;
	ControlMoterData1[6]=0x00;
	ControlMoterData1[7]=0x00;
	CAN_SendMsg(ID3, ControlMoterData1);
}	




```

这段代码是用C语言编写的，似乎是为了控制嵌入式系统中的电机速度和行为，可能用于机器人或工业机器。它通过CAN（Controller Area Network，控制器局域网络）总线与电机控制器进行交互，CAN是一种坚固的车辆总线标准，设计用于允许微控制器和设备在没有主计算机的情况下彼此通信。

以下是代码中关键组成部分和功能的详细解释：

### 全局变量
- `ControlMoterData1`、`ControlMoterData2`、`ControlMoterData3`：这些是8个有符号8位整数（`s8`）的数组。它们用于存储将通过CAN总线发送以控制电机的数据。

### 函数

#### `Set_Left_Mode`
- **目的**：配置和控制左侧电机。
- **参数**： 
  - `ID1`：CAN消息的标识符，指定目标设备（左侧电机）。
  - `Target_L_Speed_High` 和 `Target_L_Speed_Low`：这两个参数用于设置电机的目标速度。它们似乎代表一个分割的16位速度值，`Target_L_Speed_High` 是高字节，`Target_L_Speed_Low` 是低字节。
- **功能**： 
  - 发送三个单独的CAN消息（`ControlMoterData1`、`ControlMoterData2`、`ControlMoterData3`），但代码中只有第一个和第三个包是激活的。第二个被注释掉了。
  - 第一个包（`ControlMoterData1`）将电机控制类型设置为占空比控制（`0x00`）。
  - 第三个包（`ControlMoterData3`）设置电机速度。

#### `Set_Right_Mode`
- **目的**：与`Set_Left_Mode`类似，但控制右侧电机。
- **参数**： 
  - `ID2`、`Target_R_Speed_High`、`Target_R_Speed_Low`：与`Set_Left_Mode`类似，但用于右侧电机。
- **功能**：与`Set_Left_Mode`几乎相同，主要区别在于CAN ID（`ID2`）。

#### `Set_Stop`
- **目的**：停止电机。
- **参数**： 
  - `ID3`：CAN消息的标识符，指定要停止的目标设备。
- **功能**：通过设置电机控制类型为停止命令（`0x10`）来发送一个CAN消息以停止电机。

### 注释

- 代码中包含详细的中文注释，解释代码的每个部分的用途。
- 代码中的某些部分（与设置电机速度单位相关）被注释掉了，表明它们要么未被使用，要么是未来实施的功能。

### 注意事项
- `CAN_SendMsg`：这个用于发送CAN消息的函数在提供的代码中没有定义。它可能在程序的其他地方定义，或者是库的一部分。
- 代码假定熟悉特定电机控制器的CAN协议，这可以通过特定的字节模式和命令使用来看出。
- 在这个代码片段中，没有明显的错误检查或处理，这对于健壮的实际应用来说可能是至关重要的。
- 使用魔法数字（如`0x2f`、`0x2b`等）而不是命名常量，使得代码更难理解和维护。用描述它们用途的命名常量替换这些数字会更好。

## can.c

```c
#include "./bsp_can/can.h"

/**
  * @brief  配置嵌套向量中断控制器NVIC
  * @param  无
  * @retval 无
  */
static void NVIC_Configuration(void)
{
  NVIC_InitTypeDef NVIC_InitStructure;
  
  /* 设置NVIC的优先级分组 */
  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
  
  /* 配置中断源为CAN2的接收中断0 */
  NVIC_InitStructure.NVIC_IRQChannel = CAN2_RX0_IRQn;
  /* 设置抢断优先级为1 */
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
  /* 设置子优先级为0 */
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
  /* 使能中断处理 */
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  /* 应用NVIC配置 */
  NVIC_Init(&NVIC_InitStructure);
}




 /**
  * @brief  GPIO初始化，CAN初始化，NVIC初始化，CAN筛选器初始化【can控制器初始化】
  * @param  无
  * @retval 无
  */

void CAN_InitConfig (void)
{
	/* 初始化GPIO和CAN结构体变量 */
	GPIO_InitTypeDef GPIO_InitStructure;
	CAN_InitTypeDef CAN_InitStructure;

	/* 使能CAN1和CAN2的时钟 */
	RCC_APB1PeriphClockCmd(CAN_CLK1 | CAN_CLK2, ENABLE);

	/* 使能CAN RX和TX的GPIO时钟 */
	RCC_AHB1PeriphClockCmd(CAN_RX_CLK | CAN_TX_CLK, ENABLE);

	/* 配置CAN RX和TX的GPIO为复用功能 */
    GPIO_PinAFConfig(CAN_RX_PORT, CAN_RX_PinSource, CAN_RX_AF);
    GPIO_PinAFConfig(CAN_TX_PORT, CAN_TX_PinSource, CAN_TX_AF);

	/* GPIO初始化 *****************/
	 /* 配置Tx引脚为复用功能，CAN输出端 *****************/
    // 设置CAN传输引脚
    GPIO_InitStructure.GPIO_Pin = CAN_TX_PIN;
    // 配置GPIO模式为复用功能
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    // 设置GPIO速度为50MHz
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    // 设置GPIO输出类型为推挽输出
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    // 设置GPIO为上拉模式
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
    // 应用上述配置到CAN_TX_PORT端口
    GPIO_Init(CAN_TX_PORT, &GPIO_InitStructure);

	
     /* 配置Rx引脚为复用功能，CAN输入端 *****************/
    // 设置CAN接收引脚
    GPIO_InitStructure.GPIO_Pin = CAN_RX_PIN;
    // 配置GPIO模式为复用功能
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    // 设置GPIO速度为50MHz
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    // 设置GPIO输出类型为推挽输出
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    // 设置GPIO为上拉模式
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
    // 应用上述配置到CAN_RX_PORT端口
    GPIO_Init(CAN_RX_PORT, &GPIO_InitStructure);


	/* 配置CAN控制器参数 */
	CAN_InitStructure.CAN_ABOM = DISABLE;  // 自动离线管理
	CAN_InitStructure.CAN_AWUM = DISABLE;  // 自动唤醒
	CAN_InitStructure.CAN_NART = ENABLE;   // 非自动重传
	CAN_InitStructure.CAN_RFLM = DISABLE;  // 接收FIFO锁定
	CAN_InitStructure.CAN_TTCM = DISABLE;  // 时间触发通信模式
	CAN_InitStructure.CAN_TXFP = DISABLE;  // 发送优先级

	/* 设置CAN为正常通信模式，并配置波特率为500kbps */
    // 设置CAN控制器为正常模式
    CAN_InitStructure.CAN_Mode = CAN_Mode_Normal;
    // 设置同步跳变宽度为1时间量化单元
    CAN_InitStructure.CAN_SJW = CAN_SJW_1tq;
    // 设置位时间段1为7时间量化单元
    CAN_InitStructure.CAN_BS1 = CAN_BS1_7tq;
    // 设置位时间段2为6时间量化单元
    CAN_InitStructure.CAN_BS2 = CAN_BS2_6tq;
    // 设置预分频器值为6，决定了CAN总线的波特率
    CAN_InitStructure.CAN_Prescaler = 6;
    // 应用上述配置初始化CAN2控制器
    CAN_Init(CAN2, &CAN_InitStructure);


	/* 配置NVIC中断 */
	NVIC_Configuration();

	/* 使能CAN2的FIFO 0接收中断 */
	CAN_ITConfig(CAN2, CAN_IT_FMP0, ENABLE);
}


//初始化筛选器
void CAN_Filter_Config(void)//括号内的是输入参数
{
    // 初始化CAN过滤器结构体
    CAN_FilterInitTypeDef CAN_Filter_InitStruct;

    // 设置过滤器编号为14
    CAN_Filter_InitStruct.CAN_FilterNumber = 14;

    // 设置过滤器模式为标识符掩码模式
    CAN_Filter_InitStruct.CAN_FilterMode = CAN_FilterMode_IdMask;

    // 设置过滤器比例为32位
    CAN_Filter_InitStruct.CAN_FilterScale = CAN_FilterScale_32bit;

    // 配置过滤器标识符高低位
    CAN_Filter_InitStruct.CAN_FilterIdHigh = (0x0681<<5)&0xFFFF;
    CAN_Filter_InitStruct.CAN_FilterIdLow = (0|CAN_ID_STD|CAN_RTR_DATA)&0xFFFF;

    // 设置过滤器掩码
    CAN_Filter_InitStruct.CAN_FilterMaskIdHigh = 0xFF0F;
    CAN_Filter_InitStruct.CAN_FilterMaskIdLow = 0xFFFF;

    // 指定过滤器关联的FIFO为FIFO 0
    CAN_Filter_InitStruct.CAN_FilterFIFOAssignment = CAN_Filter_FIFO0;

    // 使能过滤器
    CAN_Filter_InitStruct.CAN_FilterActivation = ENABLE;

    // 应用过滤器配置
    CAN_FilterInit(&CAN_Filter_InitStruct);

	
}

/* 与motor.c里面的Set_SpeedTarget_ModeX相关联，里面的数据通过地址访问传输到这个函数里面. */
s8 CAN_SendMsg(uint32_t ID,s8*data)
{
	s8 mbox;//变量mbox用于存储发送的CAN消息在CAN总线发送邮箱中的编号。
	u16 i=0;
	
	/* CAN发送结构体初始化 */ 
	//CanTxMsg结构体用于存储要发送的CAN消息的各个参数，包括消息ID（StdId）、数据长度码（DLC）、数据（Data）等。
	CanTxMsg TxMsg;
	
	/* 数据帧发送 */
	TxMsg.StdId=ID;//0x0601;//标准标识符
	TxMsg.RTR=CAN_RTR_DATA;//数据帧
	TxMsg.IDE=CAN_Id_Standard;//标准帧
	TxMsg.DLC=8;//数据长度
	for(i=0;i<8;i++)
		TxMsg.Data[i]=data[i];//在循环中，将要发送的数据复制到CanTxMsg结构体的Data数组中。
	
	
	/* 发数据 */
	/* CAN_Transmit可把报文存储到发送邮箱，然后 CAN 外设会把它发送出去 */
	mbox=CAN_Transmit(CAN2,&TxMsg);//CAN_Transmit函数用于将CanTxMsg结构体中的数据存储到CAN总线发送邮箱中，并返回邮箱编号。
	//mbox是邮箱编号，由CAN_Tramsmit指定
	
	/* 在循环中，使用CAN_TransmitStatus函数来检查CAN总线发送状态，
	     如果状态为CAN_TxStatus_Failed，说明发送失败，继续循环等待；
	     如果状态不为CAN_TxStatus_Failed，则说明发送成功，跳出循环。 */
	while((CAN_TransmitStatus(CAN1,mbox)==CAN_TxStatus_Failed)&&(i<0XFFF))
		i++;
	
	if(i>0XFFF)//最后根据循环次数判断发送成功或失败，如果循环次数超过0XFFF，则返回0表示发送失败；否则返回1表示发送成功。
		return 0;//发送失败
	
	return 1;
	
}

//u8 SetCheckbit(CanTxMsg* txmsg)
//{
//	u8 checkbit;
//	checkbit=txmsg.
//	
//	return 
//}



```

这段代码是一个嵌入式系统的CAN（Controller Area Network）通信配置和数据发送的实现，通常用于需要高可靠性数据通信的应用，如汽车电子或工业自动化。代码的结构和功能说明如下：

### 配置NVIC（Nested Vectored Interrupt Controller）
- `NVIC_Configuration`函数负责配置中断控制器。它设置了中断优先级组，并配置了CAN2的接收中断（`CAN2_RX0_IRQn`），设置抢占优先级为1，子优先级为0，并使能了这个中断。

>这段代码是用于配置STM32微控制器的嵌套向量中断控制器（NVIC），主要用于设置CAN2接收中断的优先级和使能。代码的结构和功能解释如下：
>
>### 函数 `NVIC_Configuration`
>
>这是一个静态函数，仅在其定义的源文件中可见。
>
>#### 中断控制器组选择
>
>- `NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);`：设置NVIC的优先级分组。`NVIC_PriorityGroup_2`指定优先级分组方式，其中抢断优先级有2位，子优先级有2位。这种分组方式允许一定程度的抢断优先级和子优先级的灵活配置。
>
>#### 中断源配置
>
>- `NVIC_InitStructure.NVIC_IRQChannel = CAN2_RX0_IRQn;`：设置中断源为`CAN2_RX0_IRQn`，表示这是针对CAN2接口的接收中断0。
>
>#### 抢断优先级和子优先级
>
>- `NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;`：设置抢断优先级为1。这个值在所选择的优先级分组下定义了中断的抢断优先级。
>- `NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;`：设置子优先级为0。在同一抢断优先级下，子优先级决定了中断的相对优先级。
>
>#### 中断使能
>
>- `NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;`：使能中断，允许NVIC处理这个中断。
>
>#### 初始化NVIC
>
>- `NVIC_Init(&NVIC_InitStructure);`：使用前面配置的`NVIC_InitStructure`结构体初始化NVIC，应用中断配置。

### CAN总线初始化
- `CAN_InitConfig`函数执行多项初始化任务，以准备CAN总线通信：
  - **时钟配置**：启用CAN1和CAN2的时钟。
  - **GPIO配置**：配置CAN的TX（发送）和RX（接收）引脚，设置为复用功能，高速推挽输出，上拉模式。
  - **CAN配置**：设置CAN的工作模式（正常模式），设置通信波特率（500kbps），配置各种模式如自动离线、自动唤醒、非自动重传、FIFO锁定和时间触发模式等。
  - **NVIC配置**：调用`NVIC_Configuration`来设置中断。
  - **中断配置**：使能CAN2的FIFO 0接收中断。

>这段代码是用于初始化STM32微控制器上的CAN（Controller Area Network）总线的配置。它包括配置GPIO用于CAN通信、设置CAN控制器参数、以及中断的配置。以下是详细解释和中文注释：
>
>### 函数 `CAN_InitConfig`
>
>该函数执行了STM32上CAN总线的初始化配置。
>
>#### CAN时钟使能
>
>- `RCC_APB1PeriphClockCmd(CAN_CLK1 | CAN_CLK2, ENABLE);`：此行代码使能CAN1和CAN2的时钟。在STM32中，使用CAN2时通常需要同时使能CAN1和CAN2的时钟。这里使用的是位或操作（`|`），因为这是设置寄存器特定位的常用方法。
>
>#### GPIO时钟使能
>
>- `RCC_AHB1PeriphClockCmd(CAN_RX_CLK | CAN_TX_CLK, ENABLE);`：使能与CAN接收（RX）和发送（TX）相关的GPIO端口的时钟。
>
>#### GPIO配置
>
>- GPIO引脚被设置为复用功能模式（`GPIO_Mode_AF`），并且配置为高速推挽输出（`GPIO_Speed_50MHz`, `GPIO_OType_PP`），以及上拉模式（`GPIO_PuPd_UP`）。
>
>#### CAN引脚复用配置
>
>- `GPIO_PinAFConfig`：这些调用将特定的GPIO端口和引脚配置为CAN的TX和RX功能。
>
>#### CAN控制器配置
>
>- 设置CAN控制器的多个参数，如自动离线管理、自动唤醒、非自动重传、接收FIFO锁定、时间触发通信模式、发送优先级。
>- 设置CAN的通信模式为正常模式（`CAN_Mode_Normal`）。
>- 设置CAN通信的波特率。波特率计算依赖于APB1总线的时钟频率，这里配置为500kbps。
>
>#### NVIC配置
>
>- 调用之前定义的`NVIC_Configuration`函数，配置中断。
>
>#### CAN中断配置
>
>- `CAN_ITConfig(CAN2, CAN_IT_FMP0, ENABLE);`：使能CAN2的FIFO 0消息挂起中断。

### CAN筛选器配置
- `CAN_Filter_Config`函数设置了CAN筛选器，用于决定哪些CAN消息会被处理。
  - 设置筛选器编号、模式（掩码模式）、比例（32位）、筛选ID和掩码。
  - 设置筛选器关联的FIFO（FIFO 0）。
  - 最后使能筛选器。

>这段代码用于配置STM32微控制器中的CAN总线的过滤器，这是CAN通信中非常重要的一个环节。该过滤器决定了哪些接收到的CAN消息被接受处理，哪些被忽略。下面是对这段代码的逐行解释：
>
>### 函数定义
>```c
>void CAN_Filter_Config(void)
>```
>- 这是一个名为`CAN_Filter_Config`的函数，它不接受任何参数。这个函数用于配置CAN总线的过滤器。
>
>### 初始化CAN过滤器结构体
>```c
>CAN_FilterInitTypeDef CAN_Filter_InitStruct;
>```
>- 定义了一个名为`CAN_Filter_InitStruct`的结构体，用于配置CAN过滤器的参数。
>
>### 设置过滤器编号
>```c
>CAN_Filter_InitStruct.CAN_FilterNumber = 14;
>```
>- 将过滤器的编号设置为14。在STM32的CAN总线系统中，可能有多个过滤器，每个过滤器都有一个唯一的编号。
>
>### 设置过滤器模式
>```c
>CAN_Filter_InitStruct.CAN_FilterMode = CAN_FilterMode_IdMask; // 掩码模式
>```
>- 设置过滤器模式为“标识符掩码模式”。在这种模式下，可以使用掩码来确定过滤器应该接收或忽略哪些消息。
>
>### 设置过滤器比例
>
>```c
>CAN_Filter_InitStruct.CAN_FilterScale = CAN_FilterScale_32bit;
>```
>- 设置过滤器的比例为32位。这决定了过滤器标识符和掩码的长度。
>
>### 配置过滤器标识符
>```c
>CAN_Filter_InitStruct.CAN_FilterIdHigh = (0x0681<<5)&0xFFFF;
>CAN_Filter_InitStruct.CAN_FilterIdLow = (0|CAN_ID_STD|CAN_RTR_DATA)&0xFFFF;
>```
>- 这两行配置过滤器的标识符。`CAN_FilterIdHigh`设置了标识符的高16位，`CAN_FilterIdLow`设置了标识符的低16位。
>
>### 配置过滤器掩码
>```c
>CAN_Filter_InitStruct.CAN_FilterMaskIdHigh = 0xFF0F;
>CAN_Filter_InitStruct.CAN_FilterMaskIdLow = 0xFFFF;
>```
>- 设置过滤器的掩码，这决定了在比较标识符时哪些位必须匹配。
>
>### 指定过滤器关联的FIFO
>```c
>CAN_Filter_InitStruct.CAN_FilterFIFOAssignment = CAN_Filter_FIFO0; // 报文存储在FIFO 0
>```
>- 指定过滤器关联的FIFO（先进先出队列）。在这里，过滤器将接收的消息存储在FIFO 0。
>
>### 使能过滤器
>```c
>CAN_Filter_InitStruct.CAN_FilterActivation = ENABLE;
>```
>- 使能过滤器，使其开始工作。
>
>### 应用过滤器配置
>```c
>CAN_FilterInit(&CAN_Filter_InitStruct);
>```
>- 使用之前设置的参数初始化CAN过滤器。
>
>### 总结
>这个函数通过详细配置CAN过滤器，来确保只有符合特定条件的CAN消息被接收。这对于管理CAN网络上的数据流，以及确保只处理相关的消息非常重要。正确配置CAN过滤器对于提高系统效率和减少不必要的数据处理至关重要。

### CAN消息发送
- `CAN_SendMsg`函数用于发送CAN消息。
  - 接收消息ID和数据数组作为参数。
  - 初始化CAN发送消息结构体，设置消息ID、帧类型（数据帧）、ID扩展（标准帧）和数据长度。
  - 将数据复制到发送结构体的数据区。
  - 调用`CAN_Transmit`来发送数据，并检查发送状态。如果发送失败，会重试直到成功或超过一定次数。

>这段代码是一个用于发送CAN消息的函数，适用于STM32等微控制器。它使用了STM32的HAL库函数来实现CAN消息的发送。以下是对这个函数的逐行解释：
>
>### 函数定义
>```c
>s8 CAN_SendMsg(uint32_t ID, s8* data)
>```
>- 这是一个名为`CAN_SendMsg`的函数，它接受一个32位的标识符`ID`和一个指向数据的指针`data`作为参数。函数返回一个`signed char`（`s8`）类型的值，通常用于表示操作的成功与否。
>
>### 变量定义
>```c
>s8 mbox;
>u16 i = 0;
>```
>- `mbox`用于存储发送消息时的邮箱编号。
>- `i`用于在后面的循环中作为计数器。
>
>### CAN消息结构体初始化
>```c
>CanTxMsg TxMsg;
>TxMsg.StdId = ID;
>TxMsg.RTR = CAN_RTR_DATA;
>TxMsg.IDE = CAN_Id_Standard;
>TxMsg.DLC = 8;
>```
>- 这里初始化了一个`CanTxMsg`类型的结构体`TxMsg`，用于存储要发送的CAN消息。
>- `StdId`设置为传入的ID，表示标准格式的标识符。
>- `RTR`设置为`CAN_RTR_DATA`，表示这是一个数据帧而不是远程帧。
>- `IDE`设置为`CAN_Id_Standard`，表示使用标准标识符。
>- `DLC`设置为8，表示数据长度为8字节。
>
>### 数据加载
>```c
>for(i = 0; i < 8; i++)
>    TxMsg.Data[i] = data[i];
>```
>- 这个循环将传入的数据复制到`TxMsg`的数据字段中。
>
>### 发送数据
>```c
>mbox = CAN_Transmit(CAN2, &TxMsg);
>```
>- 使用`CAN_Transmit`函数发送消息。这个函数将消息放入一个发送邮箱，并返回该邮箱的编号存储在`mbox`中。
>
>  - 这段代码是STM32微控制器中用于发送CAN消息的函数。该函数配置一个CAN传输邮箱，并发送一个CAN消息。以下是对代码的逐行解释：
>
>    ### 函数定义
>    ```c
>    uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
>    ```
>    - 这是一个名为`CAN_Transmit`的函数，它接受一个指向CAN总线类型的指针`CANx`和一个指向要发送的CAN消息结构体的指针`TxMessage`。函数返回一个`uint8_t`类型的值，表示使用的邮箱编号或发送失败的状态。
>
>    ### 变量定义
>    ```c
>    uint8_t transmit_mailbox = 0;
>    ```
>    - 定义了一个变量`transmit_mailbox`，用于存储将要使用的发送邮箱的编号。
>
>    ### 参数检查
>    ```c
>    assert_param(IS_CAN_ALL_PERIPH(CANx));
>    assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
>    assert_param(IS_CAN_RTR(TxMessage->RTR));
>    assert_param(IS_CAN_DLC(TxMessage->DLC));
>    ```
>    - 这些行使用断言检查传入参数的有效性，确保CAN接口、ID类型、RTR位和DLC的值都是有效的。
>
>    ### 选择一个空的传输邮箱
>    ```c
>    if ((CANx->TSR & CAN_TSR_TME0) == CAN_TSR_TME0) { ... }
>    else if ((CANx->TSR & CAN_TSR_TME1) == CAN_TSR_TME1) { ... }
>    else if ((CANx->TSR & CAN_TSR_TME2) == CAN_TSR_TME2) { ... }
>    else { transmit_mailbox = CAN_TxStatus_NoMailBox; }
>    ```
>    - 这些行检查哪个邮箱是空的（可用于发送）。如果所有邮箱都被占用，则`transmit_mailbox`被设置为`CAN_TxStatus_NoMailBox`。
>
>    ### 配置CAN消息
>    ```c
>    /* Set up the Id */
>    /* Set up the DLC */
>    /* Set up the data field */
>    ```
>    - 这些行根据提供的`TxMessage`中的信息配置CAN消息，包括设置标准或扩展ID、数据长度（DLC）和数据字段。
>
>    ### 请求发送
>    ```c
>    CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
>    ```
>    - 这行代码在选定的邮箱中设置传输请求位，触发CAN控制器开始发送过程。
>
>    ### 返回值
>    ```c
>    return transmit_mailbox;
>    ```
>    - 函数返回使用的邮箱编号，或者如果没有可用邮箱则返回`CAN_TxStatus_NoMailBox`。
>
>    ### 总结
>
>    这个函数是CAN通信中常见的一个模式，用于准备并发送CAN消息。它涉及到选择一个空闲的邮箱、配置消息参数（如ID、DLC、数据内容）以及触发传输过程。正确的实现确保了CAN消息能夠有效且可靠地被发送到网络上。
>
>
>### 检查发送状态
>
>```c
>while((CAN_TransmitStatus(CAN1, mbox) == CAN_TxStatus_Failed) && (i < 0XFFF))
>    i++;
>```
>- 这个循环检查消息是否成功发送。如果发送失败，并且计数器`i`小于`0XFFF`，则继续等待。
>
>### 判断发送结果
>
>```c
>if(i > 0XFFF)
>    return 0; // 发送失败
>return 1; // 发送成功
>```
>- 如果循环计数器超过了`0XFFF`，表示发送失败，函数返回0。
>- 否则，表示发送成功，函数返回1。
>
>### 总结
>这个函数封装了CAN消息的发送过程，包括准备消息数据、发送消息、以及检查发送状态。它对于实现CAN通信的应用程序来说是基础且必要的。

### 注释和编码风格
- 代码中的注释使用中文，清楚地解释了每个步骤的目的和功能。
- 使用了中文注释来描述复杂的硬件操作，这对于非专业人士来说可能难以理解。
- 代码结构清晰，遵循了一定的编程规范。

### 注意事项
- 这段代码假设读者熟悉CAN总线通信和STM32系列微控制器的相关硬件配置。
- 在实际应用中，需要根据具体的硬件和需求进行调整。
- 错误处理在这段代码中并不明显，对于健壮性要求高的应用，可能需要增加更详细的错误检查和处理逻辑。

## main.c

```c
#include "./bsp_can/can.h"
#include "./bsp_motor/motor.h"
#include "./bsp_key/bsp_key.h"
#include "./delay/delay.h"
#include "stm32f4xx.h"
#include "./usart/bsp_debug_usart.h"
 /**
  * @brief  New main Function
  * @param  无
  * @retval 无
  */

int i=2;

uint8_t rec_flag = 0;

static void can_delay(__IO u32 nCount)
{
	for(; nCount != 0; nCount--);
} 


/* 用于stn32f4xx_it.c中的extern CanRxMsg Rxmsg;这一句 *****************/
CanTxMsg Txmsg;
CanRxMsg Rxmsg;

int main(void)
{	
	//初始化CAN，CAN筛选器
	CAN_InitConfig();
	CAN_Filter_Config();
	//初始化按键
	Key_GPIO_Config();
	
	Debug_USART_Config();
	
//	Usart_SendString( DEBUG_USART,"这是一个串口中断接收回显实验\n");
	SysTick_Init();
	
	while(1)
	{
		/* 电机测试命令 *****************/
		//Set_Left_Mode(0x0601,0xFF,0x38);
		//Set_Right_Mode(0x0602,0xFF,0x38);
	}

}
/*********************************************END OF FILE**********************/






```

这段代码是一个嵌入式系统程序的主函数（`main`），用于STM32F4系列微控制器。代码的结构和功能如下：

### 包含的头文件
- `#include`语句用于包含所需的头文件，这些文件提供了CAN总线、电机控制、按键处理、延时处理、STM32F4硬件特性以及串口调试的相关功能。

### 全局变量
- `int i = 2;`：定义了一个整型变量`i`，初始化为2。但在程序中未看到具体用途。
- `uint8_t rec_flag = 0;`：定义了一个8位无符号整型变量`rec_flag`，可能用于标记某种状态，如接收状态，初始化为0。
- `CanTxMsg Txmsg;` 和 `CanRxMsg Rxmsg;`：定义了CAN总线的发送和接收消息结构体，用于CAN通信。

### `main`函数
- **功能**：`main`函数是程序的入口点，这里设置了系统的初始化和主循环。
- **初始化**：
  - 调用`CAN_InitConfig()`和`CAN_Filter_Config()`进行CAN总线和筛选器的初始化。
  - 调用`Key_GPIO_Config()`进行按键的GPIO配置。
  - 调用`Debug_USART_Config()`进行调试用的串口配置。
  - 调用`SysTick_Init()`初始化系统滴答定时器，用于提供时间基准或延时。
- **主循环**（`while(1)`）：
  - 当前主循环是空的，只包含注释掉的电机测试命令（`Set_Left_Mode`和`Set_Right_Mode`）。这表明主循环待填充具体逻辑或功能。

### `can_delay`函数
- 自定义的简单延时函数，接受一个计数参数`nCount`，通过空循环来实现延时。

### 注释和编码风格
- 代码中的注释用于解释函数调用和程序的结构。注释是中文的，便于中文读者理解。
- 代码整洁有序，遵循了一定的编程规范。

### 注意事项
- 代码目前的状态是一个框架或模板，主要用于初始化，实际的功能逻辑（如对CAN消息的处理、按键响应等）需要在主循环中实现。
- 代码中的`can_delay`函数使用了忙等待延时，这在实际应用中可能不是最佳选择，因为它会占用处理器资源。更好的实践是使用定时器中断或操作系统的延时功能（如果有操作系统）。
- 在实际项目中，应根据具体的硬件配置和需求调整初始化代码和主循环中的逻辑。

## bsp_debug_usart.c

```c

#include "./usart/bsp_debug_usart.h"

const unsigned char header=0xAA;
const unsigned char ender =0x0D;
 /**
  * @brief  配置嵌套向量中断控制器NVIC
  * @param  无
  * @retval 无
  */
static void NVIC_Configuration(void)
{
    NVIC_InitTypeDef NVIC_InitStructure;
  
    /* 嵌套向量中断控制器组选择 */
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
  
    /* 配置USART为中断源 */
    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;

    /* 抢断优先级为1 */
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    /* 子优先级为1 */
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    /* 使能中断 */
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    /* 初始化配置NVIC */
    NVIC_Init(&NVIC_InitStructure);
}


 /**
  * @brief  DEBUG_USART GPIO 配置,工作模式配置。115200 8-N-1 ，中断接收模式
  * @param  无
  * @retval 无
  */
void Debug_USART_Config(void)
{
  GPIO_InitTypeDef GPIO_InitStructure;
  USART_InitTypeDef USART_InitStructure;
		
  RCC_AHB1PeriphClockCmd(DEBUG_USART_RX_GPIO_CLK|DEBUG_USART_TX_GPIO_CLK,ENABLE);

  /* 使能 USART 时钟 */
  RCC_APB2PeriphClockCmd(DEBUG_USART_CLK, ENABLE);
  
  /* GPIO初始化 */
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;  
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  
  /* 配置Tx引脚为复用功能  */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_PIN  ;  
  GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &GPIO_InitStructure);

  /* 配置Rx引脚为复用功能 */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_PIN;
  GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &GPIO_InitStructure);
  
 /* 连接 PXx 到 USARTx_Tx*/
  GPIO_PinAFConfig(DEBUG_USART_RX_GPIO_PORT,DEBUG_USART_RX_SOURCE,DEBUG_USART_RX_AF);

  /*  连接 PXx 到 USARTx__Rx*/
  GPIO_PinAFConfig(DEBUG_USART_TX_GPIO_PORT,DEBUG_USART_TX_SOURCE,DEBUG_USART_TX_AF);
  
  
  /* 配置USART初始化结构体 */
  /* 波特率设置：DEBUG_USART_BAUDRATE */
  USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;
  /* 字长(数据位+校验位)：8 */
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
  /* 停止位：1个停止位 */
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
  /* 校验位选择：不使用校验 */
  USART_InitStructure.USART_Parity = USART_Parity_No;
  /* 硬件流控制：不使用硬件流 */
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  /* USART模式控制：同时使能接收和发送 */
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
  /* 完成USART初始化配置 */
  USART_Init(DEBUG_USART, &USART_InitStructure); 
  
  /* 嵌套向量中断控制器NVIC配置 */
  NVIC_Configuration();
  
  /* 使能串口接收中断 */
  USART_ITConfig(DEBUG_USART, USART_IT_RXNE, ENABLE);
 
  /* 为了解决串口会出现频繁跳中断，导致无法执行主循环的问题 ，为了后面清楚ORE中断做准备*/
  USART_ITConfig(USART1, USART_IT_PE, ENABLE);    //开启PE错误接收中断Bit 8PEIE: PE interrupt enable
  USART_ITConfig(USART1, USART_IT_ERR, ENABLE);   //CR2 开启ERR中断

  /* 使能串口 */
  USART_Cmd(DEBUG_USART, ENABLE);
}

/*****************  发送一个字符 **********************/
void Usart_SendByte( USART_TypeDef * pUSARTx, uint8_t ch)
{
	/* 发送一个字节数据到USART */
	USART_SendData(pUSARTx,ch);
		
	/* 等待发送数据寄存器为空 */
	while (USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET);	
}


 /**
  * @brief  ***************串口发送函数，与usartSendData函数相照应**************
  * @param  无
  * @retval 无
  */
void USART_Send_String(u8 *p,u16 sendSize)
{ 
	static int length =0;
	while(length<sendSize)
	{   
		//@@@@@#####如果你使用不是USART1更改成相应的，比如USART3，这里有两处修改
		while( !(USART1->SR&(0x01<<7)) );//发送缓冲区为空
		USART1->DR=*p;                   
		p++;
		length++;
	}
	length =0;
}


/*****************  发送字符串 **********************/
void Usart_SendString( USART_TypeDef * pUSARTx, char *str)
{
	unsigned int k=0;
  do 
  {
      Usart_SendByte( pUSARTx, *(str + k) );
      k++;
  } while(*(str + k)!='\0');
  
  /* 等待发送完成 */
  while(USART_GetFlagStatus(pUSARTx,USART_FLAG_TC)==RESET)
  {
	  
  }
}

/*****************  发送一个16位数 **********************/
void Usart_SendHalfWord( USART_TypeDef * pUSARTx, uint16_t ch)
{
	uint8_t temp_h, temp_l;
	
	/* 取出高八位 */
	temp_h = (ch&0XFF00)>>8;
	/* 取出低八位 */
	temp_l = ch&0XFF;
	
	/* 发送高八位 */
	USART_SendData(pUSARTx,temp_h);	
	while (USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET);
	
	/* 发送低八位 */
	USART_SendData(pUSARTx,temp_l);	
	while (USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET);	
}

///重定向c库函数printf到串口，重定向后可使用printf函数
int fputc(int ch, FILE *f)
{
		/* 发送一个字节数据到串口 */
		USART_SendData(DEBUG_USART, (uint8_t) ch);
		
		/* 等待发送完毕 */
		while (USART_GetFlagStatus(DEBUG_USART, USART_FLAG_TXE) == RESET);		
	
		return (ch);
}

///重定向c库函数scanf到串口，重写向后可使用scanf、getchar等函数
int fgetc(FILE *f)
{
		/* 等待串口输入数据 */
		while (USART_GetFlagStatus(DEBUG_USART, USART_FLAG_RXNE) == RESET);

		return (int)USART_ReceiveData(DEBUG_USART);
}

union receivedata1
{
	short d;
	unsigned char data[2];
}num;



u8 checkbit_send_to_pc=0;//设置校验位

 /**
  * @brief  上发给PC端的函数
  * @param  无
  * @retval 无
  */
void usartSendData(u8 leftvelhigh,u8 leftvellow,u8 rightvelhigh,u8 rightvellow)
{
//	unsigned int m=0;
	u8 buf[9]={0};
	num.d+=1;
	
	if(num.d>=100)
	{
			num.d = 0;
	}
	
	buf[0]=header;//这个是发给上位机的包头0xAA
	buf[1]=leftvelhigh;
	buf[2]=leftvellow;
	buf[3]=rightvelhigh;
	buf[4]=rightvellow;
	
	checkbit_send_to_pc=(buf[1]+buf[2]+buf[3]+buf[4])&0xFF;
	
	buf[5]=checkbit_send_to_pc;
	buf[6]=num.data[1];
	buf[7]=num.data[0];
	buf[8]=ender;//0x0d
//	Usart_SendString(USART1,buf);//
	//不能用发字符串的方式，因为如果有0x00的字符时就会判断为末尾，导致剩下无法发送
	
	
	/* 老方法 *****************/
//	for(m=0;m<=5;m++)
//	{
//		Usart_SendByte(USART1,buf[m]);
//	}
	
	
	//新方法
	USART_Send_String(buf,sizeof(buf));
}
/*********************************************END OF FILE**********************/

```

这段代码主要用于配置和使用STM32F4系列微控制器的USART（通用同步异步收发传输器）功能，主要用于串行通信。代码结构和功能解释如下：

### 包含的头文件
- `#include "./usart/bsp_debug_usart.h"`：包含了用于调试USART的相关定义和函数声明。

### 常量定义
- `header` 和 `ender`：定义了数据包的起始和结束标志，用于标识数据包的开始和结束。

### NVIC配置
- `NVIC_Configuration`函数：配置了中断控制器（NVIC），用于处理USART中断。设置了中断源、抢断优先级、子优先级，并使能了中断。

### USART配置
- `Debug_USART_Config`函数：配置了用于调试的USART接口。包括GPIO配置、USART初始化（波特率、数据位、停止位、校验位、硬件流控制、模式）、NVIC配置和使能USART中断。
- 使用了115200波特率，8数据位，无校验位，1停止位的设置。

### 串口发送函数
- `Usart_SendByte`：发送单个字节到USART。
- `USART_Send_String`：发送字符串到USART。使用循环发送每个字符直到发送完毕。
- `Usart_SendString`：另一个发送字符串的实现。逐字符发送，等待每个字符发送完成后发送下一个字符。
- `Usart_SendHalfWord`：发送16位数值，分为两个字节发送。

### 重定向C库函数
- `fputc`和`fgetc`：这两个函数重定向了C标准库中的`printf`和`scanf`函数到USART，使得可以使用`printf`和`scanf`进行串口通信。

### 自定义数据类型
- `union receivedata1`：一个联合体，用于方便地处理short类型数据和其字节表示的转换。

### USART通信函数
- `usartSendData`：用于发送数据到PC。数据包括左右电机的速度值，校验位和计数器。使用自定义的协议（包头、数据、校验位、包尾）进行数据封装和发送。

### 注释和编码风格
- 代码中的注释用中文撰写，清晰地解释了每个部分的功能和用途。
- 代码风格整洁，逻辑清晰。

### 注意事项
- `USART_Send_String`函数在发送字符串时，没有考虑字符串中可能包含的空字符（`\0`），这可能导致字符串提前终止。
- 在实际应用中，需要根据具体硬件配置和需求调整USART的配置。
- 在高可靠性要求的应用中，可能需要增加更详细的错误检查和处理逻辑。

## stm32f4xx_it.c

```c
/**
  ******************************************************************************
  * @file    FMC_SDRAM/stm32f4xx_it.c 
  * @author  MCD Application Team
  * @version V1.0.1
  * @date    11-November-2013
  * @brief   Main Interrupt Service Routines.
  *         This file provides template for all exceptions handler and
  *         peripherals interrupt service routine.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
#include "stm32f4xx_it.h"
#include "./usart/bsp_debug_usart.h"
#include "./bsp_can/can.h"
#include "./bsp_motor/motor.h"

int8_t buf[8] = {0};
int buf_size =0;//帧长度
#define Max_BUFF_Len 8
union Buffer_transform
{
	unsigned char us;
	signed char s;
}buf_trans;

signed char Uart1_Buffer[Max_BUFF_Len];

unsigned int Uart1_Rx=0;
int leftvel=0;
int rightvel=0;
int linear_vel=0;

extern __IO u32 TimingDelay;

unsigned char abc[3]="123";

s8 checkbit_rec=0;//设置校验位
//共用体
union receivedata
{
	short d;
	signed char data[2];
}rightvel_compare,leftvel_compare;

/** @addtogroup STM32F429I_DISCOVERY_Examples
  * @{
  */

/** @addtogroup FMC_SDRAM
  * @{
  */ 

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

/******************************************************************************/
/*            Cortex-M4 Processor Exceptions Handlers                         */
/******************************************************************************/

/**
  * @brief  This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
}

/**
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
  {}
}

/**
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
  {}
}

/**
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
  {}
}

/**
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
  {}
}

/**
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{}

/**
  * @brief  This function handles SVCall exception.
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{}

/**
  * @brief  This function handles PendSV_Handler exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{}

/**
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
     	if (TimingDelay != 0x00)
	{ 
		TimingDelay--;
	}
}

/******************************************************************************/
/*                 STM32F4xx Peripherals Interrupt Handlers                   */
/*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */
/*  available peripheral interrupt handler's name please refer to the startup */
/*  file (startup_stm32f429_439xx.s).                         */
/******************************************************************************/
void DEBUG_USART_IRQHandler(void)
{
	static signed char ch;
	//开启CR3,bit0的EIE: Error interrupt enable, 处理USART_IT_ERR,USART_IT_ORE_ER,USART_IT_NE,USART_IT_FE   错误
    if(USART_GetFlagStatus(USART1, USART_FLAG_ORE) != RESET)
    {        //同  @arg USART_IT_ORE_ER : OverRun Error interrupt if the EIE bit is set    
//        ch = USART_ReceiveData(USART1);
		buf_trans.us = USART_ReceiveData(USART1); //取出来扔掉
        USART_ClearFlag(USART1, USART_FLAG_ORE);
    }

    if(USART_GetFlagStatus(USART1, USART_FLAG_NE) != RESET)
    {        //同  @arg USART_IT_NE : Noise Error interrupt
        USART_ClearFlag(USART1, USART_FLAG_NE);
    }


    if(USART_GetFlagStatus(USART1, USART_FLAG_FE) != RESET)
    {        //同   @arg USART_IT_FE     : Framing Error interrupt
        USART_ClearFlag(USART1, USART_FLAG_FE);
    }

    if(USART_GetFlagStatus(USART1, USART_FLAG_PE) != RESET)
    {        //同  @arg USART_IT_PE     : Parity Error interrupt
        USART_ClearFlag(USART1, USART_FLAG_PE);
    }

	/* 重要中断的执行程序 *****************///
	if(USART_GetITStatus(USART1,USART_IT_RXNE) != RESET) //中断产生 
	{		 
		buf_trans.us = USART_ReceiveData(USART1);     //接收串口1数据到buff缓冲区
		Uart1_Buffer[Uart1_Rx] = buf_trans.s;
//		ch = USART_ReceiveData(USART1);     //接收串口1数据到buff缓冲区
//		Uart1_Buffer[Uart1_Rx] = ch;
		Uart1_Rx++; 
		USART_ClearITPendingBit(USART1,USART_IT_RXNE); //清除中断标志
//		printf("%d",Uart1_Rx);
		if(Uart1_Buffer[Uart1_Rx-1] == 0x0D || Uart1_Rx == Max_BUFF_Len)
		{
			printf("中断产生 ");
			printf("%x ",Uart1_Buffer[0]);
			printf("%x ",Uart1_Buffer[1]);
			printf("%x ",Uart1_Buffer[2]);
			printf("%x ",Uart1_Buffer[3]);
			printf("%x ",Uart1_Buffer[4]);
			printf("%x ",Uart1_Buffer[5]);
			printf("%x ",Uart1_Buffer[6]);
			printf("%x ",Uart1_Buffer[7]);
			
			checkbit_rec = (Uart1_Buffer[0]+Uart1_Buffer[1]+Uart1_Buffer[2]+Uart1_Buffer[3]+Uart1_Buffer[4]+Uart1_Buffer[5])&0xFF;
			if(Uart1_Buffer[0] == 0xffffffAA && Uart1_Buffer[7] == 0x0D  )
			{
				printf("校验成功 ");
				
				switch(Uart1_Buffer[1])
				{
					case 0x01://左右轮分开控制
//						printf("进入switch ");
//						printf("%x ",Uart1_Buffer[0]);
//			            printf("%x ",Uart1_Buffer[1]);
//			            printf("%x ",Uart1_Buffer[2]);
//			            printf("%x ",Uart1_Buffer[3]);
//			            printf("%x ",Uart1_Buffer[4]);
//			            printf("%x ",Uart1_Buffer[5]);
//			            printf("%x ",Uart1_Buffer[6]);
//			            printf("%x ",Uart1_Buffer[7]);
				        leftvel_compare.data[0]=Uart1_Buffer[3];
				        leftvel_compare.data[1]=Uart1_Buffer[2];
					    Set_Left_Mode(0x0601,Uart1_Buffer[2],Uart1_Buffer[3]);
					
					    rightvel_compare.data[0]=Uart1_Buffer[6];
					    rightvel_compare.data[1]=Uart1_Buffer[5];
					    Set_Right_Mode(0x0602,Uart1_Buffer[4],Uart1_Buffer[5]);
					  break;
					
					case 0x02://两个轮子各自的速度
						Set_Stop(0x0601);
					    Set_Stop(0x0602);
						break;
				}
			
				Uart1_Rx=0;                                   
			} 
			else
			{
				Uart1_Rx=0;                                   //不是我们需要的数据或者达到最大接收数则开始重新接收
			}
				printf("结束 ");
		}
		
	}

}

extern uint8_t rec_flag;
extern CanRxMsg Rxmsg;//为什么要在main.c中定义CanRxMsg Rxmsg;





/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/


```

此代码段是STM32微控制器固件库中的中断服务例程文件的一部分，它包含了对多个常见异常和中断的处理逻辑。代码主要涉及Cortex-M4处理器的异常处理，以及特定外设（例如USART1和CAN）的中断处理。

下面是对该代码段的详细解释：

1. **文件信息**：
   - 提供了文件名、作者、版本号、日期和简要说明。

2. **版权信息**：
   - 包含了版权声明和链接到STMicroelectronics的软件许可协议。

3. **包含的头文件**：
   - 引入了中断服务函数所需的头文件。

4. **全局变量定义**：
   - 定义了一些将在中断服务例程中使用的全局变量。

5. **中断处理函数**：
   - 提供了对非掩蔽中断（NMI）、硬件故障（HardFault）、内存管理错误（MemManage）、总线错误（BusFault）、用法错误（UsageFault）、调试监控器（DebugMon）、系统服务调用（SVC）、PendSV和SysTick定时器中断的默认处理函数。

6. **USART1中断处理** (`DEBUG_USART_IRQHandler`)：
   - 这是USART1中断的处理函数，其中包含了错误处理和接收数据处理的逻辑。
   - 如果发生了错误（如溢出、噪声、帧错误或奇偶校验错误），相应的错误标志会被清除。
   - 如果接收到数据（`USART_IT_RXNE`标志被设置），数据会被读取并存储在`Uart1_Buffer`数组中。如果收到终止字符（0x0D）或达到最大缓冲长度，会对数据进行处理。

   >这段代码位于STM32微控制器的USART1中断服务例程（ISR）内，负责处理接收到的串行数据。这里主要完成的任务包括接收数据、检查数据完整性以及根据接收到的命令执行相应的动作。
   >
   >代码逐行解释如下：
   >
   >1. **检查USART接收中断标志**：
   >   ```c
   >   if(USART_GetITStatus(USART1,USART_IT_RXNE) != RESET)
   >   ```
   >   如果USART1的接收数据寄存器非空中断（RXNE）被设置，说明有新的数据可以读取。
   >
   >2. **从USART读取数据**：
   >   ```c
   >   buf_trans.us = USART_ReceiveData(USART1);
   >   Uart1_Buffer[Uart1_Rx] = buf_trans.s;
   >   Uart1_Rx++;
   >   ```
   >   接收到的数据被读取并存储在`Uart1_Buffer`数组中，`Uart1_Rx`用作缓冲区的索引计数器。
   >
   >   1. `USART_ReceiveData(USART1);`
   >      - 这是一个库函数调用，用于从USART1的接收数据寄存器中读取接收到的数据。USART1是STM32上的一个串行通信接口，此函数调用会返回USART1的接收数据寄存器中的值。
   >   2. `buf_trans.us = USART_ReceiveData(USART1);`
   >      - 这行代码将接收到的数据赋值给`buf_trans.us`。这里的`buf_trans`是一个联合体（union），它允许以不同的数据类型访问同一段内存。在这个上下文中，`us`可能是联合体的成员之一，用来以无符号字符的形式存储8位数据。
   >   3. `Uart1_Buffer[Uart1_Rx] = buf_trans.s;`
   >      - 这行代码将通过`buf_trans`联合体以有符号字符（`signed char`）的形式接收的数据存储到`Uart1_Buffer`数组的当前索引位置。`Uart1_Rx`是一个计数器，它指示下一个要写入的`Uart1_Buffer`数组的位置。
   >   4. `Uart1_Rx++;`
   >      - 这行代码递增索引计数器`Uart1_Rx`，为接收下一个字符做准备。
   >   
   >3. **清除中断标志位**：
   >   ```c
   >   USART_ClearITPendingBit(USART1,USART_IT_RXNE);
   >   ```
   >   清除USART1的接收中断标志，准备接收下一个字符。
   >
   >4. **检查消息完整性**：
   >   ```c
   >   if(Uart1_Buffer[Uart1_Rx-1] == 0x0D || Uart1_Rx == Max_BUFF_Len)
   >   ```
   >   如果接收到的字符是回车（0x0D）或缓冲区已满，将会检查整个消息。
   >
   >5. **打印接收到的消息**：
   >   ```c
   >   printf("中断产生 ");
   >   // 打印整个Uart1_Buffer数组
   >   ```
   >   如果条件满足，打印出接收到的整条消息，用于调试。
   >
   >6. **计算并检查校验位**：
   >   ```c
   >   checkbit_rec = (Uart1_Buffer[0]+Uart1_Buffer[1]+...+Uart1_Buffer[5])&0xFF;
   >   if(Uart1_Buffer[0] == 0xffffffAA && Uart1_Buffer[7] == 0x0D)
   >   ```
   >   计算消息的校验和，并检查消息的开始和结束字节是否正确。这里的校验和是简单的累加校验。
   >
   >7. **根据命令执行动作**：
   >   ```c
   >   switch(Uart1_Buffer[1])
   >   {
   >       // 根据接收到的第二个字节的命令，执行相应的动作
   >   }
   >   ```
   >   根据接收到的命令（在`Uart1_Buffer`的第二个元素中），执行不同的操作，如设置左轮模式、右轮模式或停止。
   >
   >8. **重置缓冲区索引**：
   >   ```c
   >   Uart1_Rx = 0;
   >   ```
   >   完成一次消息处理后，重置索引计数器以准备接收新的消息。
   >
   >总体而言，这段代码实现了从USART1接收数据的完整过程，并根据接收到的数据执行了特定的控制命令。这种模式是在嵌入式系统中处理串口通信的典型方式。
   
7. **CAN接收中断处理** (`CAN1_RX0_IRQHandler`)：
   - 这通常是CAN接收消息中断的处理函数。在这段代码中，它没有被直接实现，但可能在其他地方定义。

8. **其他**：
   - 文件的末尾包含了STMicroelectronics的版权声明。

代码中的`DEBUG_USART_IRQHandler`函数特别复杂，它处理来自USART1的数据接收。它首先处理可能的错误，然后读取接收到的字符，存储在循环缓冲区中，并在接收到特定字符或达到最大长度时执行用户定义的操作。这个例程也展示了如何使用共用体（union）来转换数据类型和访问数据的不同视图。

注意，这段代码中有一句注释提到的`CanRxMsg Rxmsg;`变量通常是在主程序文件（如`main.c`）中定义的，这是为了在整个程序中接收CAN消息。

最后，代码中的`SysTick_Handler`函数是系统滴答定时器的中断服务例程，通常用于操作系统的时钟滴答或定时任务。在这里，它递减了一个全局变量`TimingDelay`，这个变量通常用于实现延迟功能。

## 杂

### GPIO的复用

GPIO（通用输入输出）引脚的复用功能是微控制器（如STM32系列）中一种重要的功能，它允许GPIO引脚除了基本的数字输入输出功能外，还能承担特定的外设功能，如UART、SPI、I2C通信或者定时器等。这种复用功能提高了微控制器引脚的灵活性和效率。

#### GPIO引脚复用功能的解释

1. **引脚复用概念**：在微控制器中，一个引脚往往能承担多种功能。引脚复用功能使得同一引脚可以根据需要被配置为不同的功能，例如，一个引脚可以作为普通的数字输入输出，也可以作为SPI的SCK时钟线，或者作为UART的TX传输线。

2. **功能多样性**：复用功能通常包括外设接口（如UART、SPI、I2C、CAN等）、定时器/计数器、PWM输出、外部中断线等。

3. **引脚限制**：并非所有GPIO引脚都支持所有类型的复用功能，具体支持哪些功能依赖于具体的微控制器型号。

4. **优势**：使用引脚复用可以更灵活地设计电路和程序，节省宝贵的GPIO资源，特别是在引脚数量有限的小型微控制器上。

#### 如何配置GPIO引脚的复用功能

以STM32为例，配置GPIO引脚的复用功能通常包括以下几个步骤：

1. **使能GPIO时钟**：首先需要使能GPIO端口的时钟。STM32的每个GPIO端口都有独立的时钟线，使用之前必须通过RCC（Reset and Clock Control）模块来使能。

   ```c
   RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
   ```

2. **配置GPIO引脚属性**：配置引脚为复用功能模式，并设置其他属性如输出类型、速度、上拉/下拉等。

   ```c
   GPIO_InitTypeDef GPIO_InitStructure;
   GPIO_InitStructure.GPIO_Pin = GPIO_Pin_x; // 指定要配置的GPIO引脚
   GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF; // 设置为复用功能模式
   GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; // 设置速度
   GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; // 推挽输出
   GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL; // 不使用上拉或下拉
   GPIO_Init(GPIOx, &GPIO_InitStructure); // 应用配置
   ```

3. **选择特定的复用功能**：STM32使用AF（Alternate Function，备选功能）寄存器来选择GPIO引脚的具体复用功能。

   ```c
   GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_y);
   ```

   其中`GPIOx`是GPIO端口，`GPIO_PinSourcex`是引脚源，`GPIO_AF_y`是你想要选择的具体复用功能。

4. **配置与引脚相关联的外设**：根据引脚的复用功能，可能需要进一步配置相关联的外设。例如，如果引脚被配置为UART的TX，则还需要配置UART模块。

通过这些步骤，你可以将STM32的GPIO引脚配置为特定的复用功能，以满足你的应用需求。这种灵活性是微控制器设计中非常重要的一部分，它使得硬件设计可以更加紧凑和高效。

### Time Quantum（时间量化单元）

在CAN（Controller Area Network）总线通信中，时间量化单元（Time Quantum，TQ）是非常重要的概念。它是CAN总线数据传输中的基本时间单位，用于定义位时间（即传输单个位所需的时间）。整个位时间由多个时间量化单元组成，这些单元用于不同的传输阶段和校准。

#### 时间量化单元（TQ）的作用

1. **时间单位**：TQ是CAN协议中的基本时间单位。所有的时间参数（如同步跳变宽度、位时间段1和2）都是以TQ为单位来设置的。

2. **波特率决定因素**：CAN总线的波特率（数据传输速率）部分地取决于一个位时间包含多少个TQ。波特率与TQ的数量和时钟频率有关。

3. **同步和稳定性**：通过调整位时间内TQ的分配，可以优化数据传输的同步和稳定性，尤其是在不同的网络长度和传输速度下。

#### 位时间的组成

一个位时间通常由以下几个部分组成：

1. **同步段（Sync Segment）**：每个位时间的开始，用于同步不同节点上的时钟。通常固定为1个TQ。

2. **传播时间段（Propagation Segment）**：考虑到信号在总线上传播的延迟，该段时间用于补偿物理延迟。长度可变。

3. **相位缓冲段1（Phase Buffer Segment 1）**：第一个位时间调整段，用于补偿时间差异。长度可变。

4. **相位缓冲段2（Phase Buffer Segment 2）**：第二个位时间调整段，同样用于补偿时间差异。长度可变。

5. **同步跳变宽度（Sync Jump Width, SJW）**：在发生时间偏差时，允许位时间调整的最大范围。这是为了在接收到数据时能够快速同步。

#### 波特率计算

波特率的计算公式是：

 $$\text{波特率} = \frac{\text{时钟频率}}{\text{预分频器值} \times \text{位时间的TQ总数}} $$

其中，位时间的TQ总数是同步段、传播时间段、相位缓冲段1和相位缓冲段2的TQ数之和。

#### 总结

时间量化单元（TQ）在CAN总线协议中是非常关键的，它影响着数据的传输速度和网络的稳定性。通过精确地调整TQ的数量和分配，可以优化网络性能，确保数据在不同节点之间正确同步。

### Time Quantum（时间量化单元）的配置

在CAN（Controller Area Network）总线系统中，配置时间量化单元（Time Quantum，TQ）是设置CAN总线通信参数的重要部分。时间量化单元的配置影响着CAN总线的波特率和通信的稳定性。下面是配置TQ的详细步骤：

#### 1. 确定系统时钟频率

首先，需要知道微控制器的时钟频率，因为所有的时间参数都基于这个频率。在STM32微控制器中，例如，这通常是APB（Advanced Peripheral Bus）时钟。

#### 2. 选择合适的波特率

确定你的CAN网络需要运行的波特率。常见的波特率有125 kbps、250 kbps、500 kbps等。

#### 3. 计算位时间的TQ数

位时间由几个部分组成：同步段（通常是1个TQ），传播时间段，相位缓冲段1和2。位时间的总TQ数决定了波特率：

$$\text{位时间的TQ数} = 1 (\text{同步段}) + \text{传播时间段} + \text{相位缓冲段1} + \text{相位缓冲段2} $$

#### 4. 设置预分频器

预分频器用于将系统时钟分频以得到CAN模块的时钟。预分频器的值可以这样计算：

$$
\text{预分频器值} = \frac{\text{系统时钟频率}}{\text{波特率} \times \text{位时间的TQ数}}
$$

#### 5. 配置CAN控制器寄存器

使用计算得到的值配置CAN控制器的寄存器。在STM32中，这通常包括设置`CAN_InitTypeDef`结构体的相关字段：

- `CAN_Mode`：设置为正常模式或其他模式。
- `CAN_SJW`：设置同步跳变宽度，通常为1。
- `CAN_BS1`：设置相位缓冲段1的TQ数。
- `CAN_BS2`：设置相位缓冲段2的TQ数。
- `CAN_Prescaler`：设置预分频器的值。

#### 6. 应用配置

调用`CAN_Init()`函数应用这些设置。

#### 示例

假设系统时钟为42MHz，目标波特率为500kbps，位时间设为16TQ，其中同步段1TQ，传播时间段为1TQ，相位缓冲段1为8TQ，相位缓冲段2为6TQ。那么：

```c
CAN_InitTypeDef CAN_InitStructure;

// CAN配置
CAN_InitStructure.CAN_Mode = CAN_Mode_Normal;
CAN_InitStructure.CAN_SJW = CAN_SJW_1tq;
CAN_InitStructure.CAN_BS1 = CAN_BS1_8tq;  // 8TQ
CAN_InitStructure.CAN_BS2 = CAN_BS2_6tq;  // 6TQ
CAN_InitStructure.CAN_Prescaler = 42MHz / (16TQ * 500kbps) = 5.25 ≈ 5;

CAN_Init(CANx, &CAN_InitStructure);
```

在实际应用中，预分频器的值应该是一个整数，因此可能需要调整传播时间段和相位缓冲段的长度，以得到一个合适的预分频器值。

配置TQ的过程涉及对CAN总线参数的深入理解，以及对微控制器CAN控制器的准确操作。正确配置TQ对于确保CAN网络的可靠性和效率至关重要。

### 过滤器

在CAN（Controller Area Network）系统中，过滤器是一个关键的组件，它决定了哪些CAN消息被接收和处理，哪些被忽略。这对于有效管理网络上的数据流和资源至关重要，尤其是在复杂或高负荷的CAN网络中。

#### 过滤器的作用

1. **消息选择**：过滤器基于消息的标识符（ID）来判断是否接收该消息。这允许设备只处理对其操作有意义的消息，而忽略其他不相关的数据。

2. **网络管理**：在一个繁忙的CAN网络中，可能有大量的消息传输。过滤器有助于减少每个节点处理的消息数量，从而减轻网络负担并提高效率。

3. **提高性能**：通过减少处理不必要消息的时间，过滤器有助于提高系统的总体性能和响应速度。

#### 过滤器的工作原理

1. **标识符匹配**：过滤器通过比较传入的CAN消息的标识符与预设的过滤规则来决定是否接收该消息。标识符可以是标准的11位或扩展的29位。

2. **掩码和过滤规则**：过滤器通常可以通过“掩码”来设置。掩码决定了过滤器比较哪些位。例如，如果掩码设置为0x7FF，则过滤器会比较所有11位的标准ID。

3. **过滤模式**：
   - **直接模式**：在这种模式下，过滤器将传入消息的标识符与预设的一个或多个值直接比较。
   - **掩码模式**：这种模式更为灵活，它允许过滤器通过应用掩码来比较标识符的特定位。

#### 配置过滤器的步骤

1. **选择过滤器号**：在多过滤器系统中，首先需要选择要配置的过滤器号。

2. **设置过滤模式**：确定使用直接模式还是掩码模式。

3. **配置过滤器寄存器**：根据所选模式配置过滤器的寄存器，包括过滤器ID、掩码等。

4. **激活过滤器**：最后，需要激活过滤器以使其开始工作。

#### 示例

假设一个系统需要接收ID为0x123的消息，过滤器配置可能如下：

- 设置过滤器为掩码模式。
- 过滤器ID设置为0x123。
- 掩码设置为0x7FF（表示比较所有位）。
- 激活过滤器。

这样，只有标识符完全匹配0x123的消息会被接收和处理。

#### 结论

过滤器在CAN系统中扮演着关键角色，通过确保只有相关的消息被接收和处理，从而提高了系统的效率和性能。正确配置过滤器对于任何使用CAN总线的系统都是至关重要的。

### 过滤器的配置

在CAN（Controller Area Network）系统中配置过滤器是一个重要的步骤，它决定了哪些消息被接收。以下是配置CAN过滤器的一般步骤，以STM32微控制器为例：

#### 1. 选择过滤器编号

在STM32微控制器中，有多个过滤器可供选择。首先，你需要确定要使用哪一个过滤器。

```c
CAN_FilterInitStruct.CAN_FilterNumber = x; // x是要配置的过滤器编号
```

#### 2. 设置过滤器模式

过滤器可以工作在标识符列表模式或掩码模式。在掩码模式下，你可以定义一个掩码来指定过滤器应该比较哪些位。

```c
CAN_FilterInitStruct.CAN_FilterMode = CAN_FilterMode_IdMask; // 或者CAN_FilterMode_IdList
```

>在CAN（Controller Area Network）系统中，过滤器用于确定哪些接收到的消息应当被处理。CAN过滤器通常可以在两种不同的模式下工作：标识符列表模式和掩码模式。这两种模式提供了不同的方式来指定哪些消息应该被接受或忽略。
>
>### 1. 标识符列表模式（Identifier List Mode）
>
>在标识符列表模式下，过滤器使用一个预定义的标识符列表来确定是否接受特定的CAN消息。
>
>- **直接匹配**：在这种模式下，过滤器会检查每个接收到的消息的标识符，并与列表中的标识符进行比较。
>- **精确选择**：如果接收到的消息的标识符与列表中的任何一个标识符完全匹配，该消息就会被接受。
>- **应用场景**：这种模式适用于那些只需处理数量有限、特定的消息类型的应用。
>
>### 2. 掩码模式（Mask Mode）
>
>掩码模式提供了更灵活的过滤机制。在这种模式下，过滤器使用一个掩码和一个匹配标识符来确定是否接受消息。
>
>- **位掩码**：掩码是一个二进制值，用于指定哪些位在标识符比较时是重要的。'1'表示对应位需要匹配，而'0'表示对应位可以忽略。
>- **条件匹配**：当接收到的消息的标识符与过滤器的匹配标识符在所有由掩码指定的位上相同时，该消息就会被接受。
>- **应用场景**：掩码模式适用于需要灵活处理多种消息类型的应用。它允许通过设置掩码来选择性地关注标识符的特定部分。
>
>### 总结
>
>选择使用标识符列表模式还是掩码模式取决于应用的具体需求：
>
>- **标识符列表模式**更适合于那些只需要处理已知、固定数量的消息类型的场景。
>- **掩码模式**则为需要更大灵活性和能够处理多种可能消息的应用提供了更好的选择。
>
>正确配置CAN过滤器对于优化网络性能、减少不必要的数据处理和确保系统的有效响应至关重要。

|      模式      |                             说明                             |
| :------------: | :----------------------------------------------------------: |
|  32位掩码模式  | CAN_FxR1存储ID， CAN_FxR2存储哪个位必须要与CAN_FxR1中的ID一致 ， 2个寄存器表示1组掩码。 |
| 32位标识符模式 |   CAN_FxR1和CAN_FxR2各存储1个ID， 2个寄存器表示2个筛选的ID   |
|  16位掩码模式  | CAN_FxR1高16位存储ID， 低16位存储哪个位必须要与高16位的ID一致； CAN_FxR2高16位存储ID， 低16位存储哪个位必须要与高16位的ID一致 2个寄存器表示2组掩码。 |
| 16位标识符模式 |   CAN_FxR1和CAN_FxR2各存储2个ID， 2个寄存器表示4个筛选的ID   |

#### 3. 设置过滤器比例

过滤器比例可以是16位或32位。这决定了过滤器寄存器的大小。

```c
CAN_FilterInitStruct.CAN_FilterScale = CAN_FilterScale_16bit; // 或者CAN_FilterScale_32bit
```

#### 4. 定义过滤器标识符

为过滤器指定一个或多个标识符。这取决于你的过滤器模式和比例。

```c
CAN_FilterInitStruct.CAN_FilterIdHigh = 0x0000; // 标识符的高16位
CAN_FilterInitStruct.CAN_FilterIdLow = 0x0000;  // 标识符的低16位
```

>在CAN（Controller Area Network）系统中，配置过滤器时指定一个或多个标识符是为了决定哪些接收到的消息应该被处理。这个配置过程依赖于过滤器的工作模式和比例。以下是对这个过程的详细解释：
>
>### 1. 过滤器模式
>过滤器模式决定了如何匹配接收到的消息的标识符：
>
>- **标识符列表模式**：在这个模式下，过滤器对照一个预定义的标识符列表来检查接收到的每个消息。如果消息的标识符与列表中的任何一个标识符完全匹配，则该消息被接受。
>  
>- **掩码模式**：在掩码模式下，过滤器使用一个掩码（mask）和一个参考标识符来匹配消息。掩码定义了在比较过程中哪些位是关键的。如果消息的标识符与参考标识符在掩码指定的位上相匹配，则消息被接受。
>
>### 2. 过滤器比例
>过滤器比例指的是过滤器用来匹配标识符的位数：
>
>- **16位比例**：在16位比例模式下，过滤器使用16位长的标识符进行匹配。这种模式适用于标准的11位CAN标识符。
>
>- **32位比例**：32位比例模式允许使用更长的标识符，适用于扩展的29位CAN标识符。在这种模式下，可以更精确地定义哪些位需要匹配。
>
>### 指定标识符
>根据你选择的过滤器模式和比例，你可以指定一个或多个标识符：
>
>- **在标识符列表模式下**：你需要提供一个标识符列表，过滤器将检查是否有任何接收到的消息的标识符与列表中的标识符完全一致。
>
>- **在掩码模式下**：你需要设置一个参考标识符和一个掩码。掩码决定了在比较过程中哪些位是重要的。只有当消息的标识符在掩码指定的位上与参考标识符匹配时，该消息才被接受。
>
>### 总结
>为过滤器指定标识符是一个关键步骤，它确保了CAN系统只处理相关的消息，从而提高效率和性能。正确配置这些参数对于确保CAN网络的有效和精确通信至关重要。

#### 5. 设置过滤器掩码

如果你使用掩码模式，需要设置掩码。掩码决定了哪些位需要匹配。

```c
CAN_FilterInitStruct.CAN_FilterMaskIdHigh = 0xFFFF; // 掩码的高16位
CAN_FilterInitStruct.CAN_FilterMaskIdLow = 0xFFFF;  // 掩码的低16位
```

#### 6. 分配过滤器到FIFO

CAN控制器通常有两个FIFO，你需要指定消息通过该过滤器后存储到哪个FIFO。

```c
CAN_FilterInitStruct.CAN_FilterFIFOAssignment = CAN_Filter_FIFO0; // 或者CAN_Filter_FIFO1
```

#### 7. 激活过滤器

最后，激活配置的过滤器。

```c
CAN_FilterInitStruct.CAN_FilterActivation = ENABLE;
```

#### 8. 应用过滤器设置

使用初始化的结构体应用过滤器设置。

```c
CAN_FilterInit(&CAN_FilterInitStruct);
```

#### 总结

以上步骤为标准的过程，用于在STM32等微控制器上配置CAN总线的消息过滤器。正确配置过滤器能确保你的设备只接收和处理相关的CAN消息，从而提高系统的效率和可靠性。需要注意的是，具体的寄存器名称和可用选项可能因不同的微控制器型号而有所不同。

### 接收FIFO

FIFO（First In, First Out）是一种重要的数据结构，广泛应用于计算机科学和各类系统设计中，包括微控制器、操作系统、网络通信等领域。在CAN（Controller Area Network）系统中，FIFO通常用于管理接收到的消息。

#### FIFO的基本概念

1. **First In, First Out**：FIFO的核心原则是“先进先出”，意味着最先进入队列的数据项将是最先被移出的。

2. **数据缓冲**：FIFO常用作缓冲区，临时存储数据流。例如，在网络通信和串行通信中，FIFO可用于暂存接收到的数据，直到系统准备好处理这些数据。

3. **避免数据丢失**：在高速数据传输中，FIFO有助于防止在数据处理过程中发生数据丢失。

#### FIFO在CAN系统中的应用

在CAN通信中，FIFO用于管理接收到的消息：

1. **接收缓冲**：CAN控制器通常包含一个或多个FIFO队列，用作接收到的消息的缓冲区。当消息通过CAN总线到达时，它们首先被存储在FIFO中。

2. **消息管理**：FIFO允许微控制器按照接收顺序处理消息。这确保了消息的时序和优先级得到适当的管理。

3. **提高效率**：使用FIFO可以使微控制器在处理当前消息的同时继续接收更多的消息，提高了数据处理的效率。

4. **中断管理**：在许多系统中，当FIFO达到特定的填充水平时，可以配置中断通知处理器进行数据处理，这有助于实时响应通信事件。

#### FIFO的配置

在CAN系统的配置中，可以设置：

- **FIFO的分配**：指定哪个FIFO用于存储特定的接收消息。
- **FIFO的大小**：定义FIFO可以存储多少消息。
- **溢出管理**：设置当FIFO满时的行为，如覆盖旧消息或丢弃新消息。

#### 总结

FIFO在CAN系统中扮演着重要的角色，它不仅提高了数据处理的效率和可靠性，还简化了消息管理。正确配置和使用FIFO对于确保CAN通信的顺畅和高效至关重要。在嵌入式系统和实时应用中，合理利用FIFO可以显著提升系统性能和响应速度。

>CAN接收FIFO（First In, First Out）是在CAN（Controller Area Network）总线系统中用于处理接收到的消息的一种机制。FIFO的基本概念是先进先出，即最先接收的消息最先被处理。在CAN系统中，接收FIFO的使用提高了消息处理的效率和可靠性。
>
>### CAN接收FIFO的基本工作原理
>
>1. **消息缓冲**：
>   - 当CAN消息通过总线接收时，它们首先被存储在接收FIFO中。这为消息处理提供了一个缓冲区。
>
>2. **顺序处理**：
>   - FIFO按照消息到达的顺序存储和处理这些消息。最早到达的消息首先被移出FIFO并进行处理。
>
>3. **防止数据丢失**：
>   - 在高数据流量的情况下，使用FIFO可以防止消息因处理不及时而丢失。
>
>### CAN接收FIFO的配置和使用
>
>1. **FIFO大小**：
>   - 接收FIFO的大小可以根据具体应用进行配置。它定义了FIFO可以存储的消息数量。
>
>2. **消息过滤**：
>   - 通常，接收FIFO与CAN过滤器配合使用。过滤器决定哪些消息被接受到FIFO中。
>
>3. **中断和轮询**：
>   - 微控制器可以通过中断或轮询的方式来检查接收FIFO。当FIFO中有新消息时，可以配置中断来通知处理器，或者通过轮询方式定期检查FIFO。
>
>4. **读取和清空**：
>   - 从FIFO中读取消息后，该消息被移出FIFO，为新的消息腾出空间。这确保了FIFO不会溢出。
>
>### 接收FIFO的优势
>
>1. **提高效率**：
>   - FIFO允许微控制器以有序的方式处理消息，而不是立即响应每个接收到的消息，这提高了系统的总体效率。
>
>2. **减轻处理器负担**：
>   - 使用FIFO减少了处理器必须即时处理每个接收到的消息的需求，从而减轻了处理器的负担。
>
>3. **适应高流量**：
>   - 在高消息流量的情况下，FIFO提供了足够的缓冲区来处理大量的消息，防止丢失。
>
>### 总结
>CAN接收FIFO是CAN通信中重要的组件，尤其在处理大量的或高优先级的消息时显得尤为重要。正确配置和使用接收FIFO可以显著提升CAN系统的性能和可靠性，确保数据的有效处理。

### 发送邮箱

在CAN（Controller Area Network）系统中，发送邮箱是一个重要的概念，用于管理和控制通过CAN总线发送的消息。在许多微控制器的CAN控制器中，包括STM32系列，发送邮箱是硬件层面的功能，提供了有效的消息发送管理机制。

#### 发送邮箱的基本概念

1. **邮箱的作用**：发送邮箱用于暂存要通过CAN总线发送的消息。每个邮箱可以存储一条CAN消息，包括它的标识符、控制信息、数据长度和数据本身。

2. **邮箱数量**：微控制器的CAN控制器通常提供多个发送邮箱。例如，STM32的某些型号提供了三个独立的发送邮箱。

3. **优先级管理**：当多个邮箱同时准备好发送时，CAN控制器会根据特定的规则（如标识符的优先级）来决定哪个邮箱中的消息先发送。

4. **发送控制**：邮箱允许微控制器软件控制消息的发送过程，包括加载消息、启动发送和监控发送状态。

#### 发送邮箱的工作流程

1. **消息加载**：当需要通过CAN发送消息时，微控制器首先将消息数据和相关控制信息加载到一个空闲的发送邮箱中。

2. **发送请求**：加载消息后，微控制器设置邮箱状态，请求CAN控制器开始发送过程。

3. **发送处理**：CAN控制器根据内部的优先级和调度机制选择一个邮箱进行发送。如果总线空闲，控制器开始发送该邮箱中的消息。

4. **发送完成与确认**：消息发送完成后，CAN控制器通常会提供发送状态的反馈，如成功发送或错误状态。这些信息可以由微控制器用于进一步的处理或诊断。

5. **邮箱释放**：发送完成后，邮箱被标记为空闲，可以用于存储新的消息。

#### 发送邮箱的优势

1. **提高效率**：通过并行加载多个消息并根据优先级发送，邮箱机制提高了数据发送的效率。

2. **减少阻塞**：邮箱使得微控制器不需要等待每个消息的发送完成，可以继续执行其他任务。

3. **错误处理**：发送邮箱提供了监控和诊断发送错误的能力，有助于实现可靠的通信。

4. **简化软件设计**：邮箱机制简化了软件层面对CAN消息发送的控制和管理。

#### 总结

发送邮箱在CAN系统中是发送数据的关键部分，提供了有效的消息管理和发送控制机制。它使得CAN通信更加高效和可靠，对于实现复杂的嵌入式系统和汽车通信网络至关重要。通过合理利用发送邮箱，系统可以有效地管理大量的CAN消息，保证通信的顺畅和系统的稳定性。

### 报文

在CAN（Controller Area Network）总线系统中，报文（Message）是通信的基本单元。CAN报文是在总线上发送和接收的数据包，包含多个重要的字段，每个字段都有特定的功能和意义。

#### CAN报文的组成

1. **标识符（Identifier）**：
   - 标准格式的标识符是11位长，而扩展格式的标识符是29位长。
   - 标识符用于标示报文的优先级，数值越小优先级越高。

2. **远程传输请求位（RTR - Remote Transmission Request）**：
   - 用于区分数据帧和远程帧。在数据帧中，RTR位为0；在远程帧中，RTR位为1。

3. **控制字段（Control Field）**：
   - 包含数据长度代码（DLC），表示数据字段中的字节数。
   - DLC可以是0到8字节。

4. **数据字段（Data Field）**：
   - 实际的数据内容，最多可以包含8字节的数据。

5. **CRC字段（CRC Field）**：
   - 用于错误检测，包含一个15位的循环冗余校验码和一个分隔位。

6. **确认槽（ACK Slot）和ACK分隔符**：
   - 发送节点在这里放置一个重写位，而接收节点在确认槽中发送一个低电平来确认接收。

7. **帧结束字段（EOF - End of Frame）**：
   - 标记报文结束，由7个重写位组成。

#### CAN报文类型

1. **数据帧（Data Frame）**：
   - 用于传输数据，由发送节点发出。

2. **远程帧（Remote Frame）**：
   - 用于请求数据，只包含标识符和RTR位，没有数据字段。

3. **错误帧（Error Frame）**：
   - 当检测到错误时，任何节点都可以发送错误帧。

4. **过载帧（Overload Frame）**：
   - 用于延迟下一个数据或远程帧的发送。

#### 总结

CAN报文的设计允许高效、灵活且可靠的数据传输。报文结构支持多种帧类型，能够处理从基本的数据传输到复杂的错误检测和网络管理功能。在汽车和工业应用中，这些特性使CAN总线成为实现稳定和高效通信的理想选择。

### CAN

CAN（Controller Area Network）是一种广泛应用于汽车和工业自动化的网络通信协议。它使多个微控制器和设备能够在没有主机计算机的情况下相互通信。以下是CAN总线的基本工作流程：

#### 初始化

1. **系统启动**：系统上电时，CAN控制器和网络设备初始化，包括设置波特率、配置过滤器、初始化发送和接收邮箱等。

2. **总线空闲检测**：在发送任何消息之前，节点会检测总线是否空闲。

#### 消息发送

1. **消息装载**：当节点需要发送数据时，它会将数据打包成CAN报文格式，包括标识符、数据长度、数据本身以及CRC等。

2. **发送请求**：节点在总线上发送报文。如果总线空闲，报文开始传输；如果总线忙，则等待总线空闲。

3. **仲裁过程**：如果两个或多个节点同时尝试发送消息，CAN总线使用非破坏性仲裁的方式来解决冲突。这意味着具有最低标识符的报文将优先发送。

#### 消息接收和处理

1. **监听总线**：所有节点都在监听总线上的活动，即使它们没有发送数据。

2. **过滤和接收**：当报文到达时，节点使用配置的过滤器来决定是否接受该报文。如果报文与过滤器匹配，则存储于接收邮箱。

3. **处理数据**：一旦报文被接收，相应的处理程序（如中断服务例程）被触发，以处理接收到的数据。

#### 错误处理

1. **错误检测**：CAN协议内置了强大的错误检测机制，包括位级和帧级的错误检测。

2. **错误信号**：当检测到错误时，节点会发送错误帧，这会中断当前正在传输的帧。

3. **错误恢复**：在错误发生后，系统会尝试恢复通信，并重新发送受到干扰的消息。

#### 网络管理

1. **总线静默**：在错误状态或关闭状态下，节点可能进入静默模式，此时它只监听总线而不参与通信。

2. **系统监控**：一些高级CAN系统包括网络管理功能，用于监控和控制网络状态。

#### 总结

CAN总线的工作流程旨在提供一种高效、可靠且灵活的通信方式。其核心特点包括多主通信、消息优先级、非破坏性仲裁、强大的错误检测与处理机制，以及低成本实现。这些特性使CAN成为了汽车电子和工业自动化领域的首选通信协议。

### CAN ID

在CAN（Controller Area Network）总线系统中，CAN ID（标识符）是用于标识不同消息的关键元素。CAN ID确保了消息正确地被路由和处理，是CAN总线通信机制的核心部分。

#### CAN ID的基本概念

1. **唯一性**：
   - CAN ID是每个CAN消息的唯一标识。在CAN网络中，不同的消息应该有不同的CAN ID。

2. **优先级**：
   - 在CAN总线上，CAN ID还定义了消息的优先级。数值较低的CAN ID具有更高的优先级。在多个设备同时尝试发送消息时，优先级较高（即ID值较小）的消息会被优先传输。

3. **标准与扩展格式**：
   - CAN标准定义了两种ID格式：标准格式和扩展格式。
   - **标准格式**：具有11位的标识符，允许在0到0x7FF（0至2047）范围内的值。
   - **扩展格式**：具有29位的标识符，扩展了ID的范围，允许在0到0x1FFFFFFF（0至536870911）范围内的值。

#### CAN ID在消息中的位置

在CAN消息帧结构中，ID位于帧的开始位置，紧接在帧开始标志之后。这允许在数据传输的初期进行消息仲裁（决定哪个消息首先传输）。

#### CAN ID的应用

1. **消息识别**：
   - 在CAN网络中，接收节点使用CAN ID来识别消息内容和来源，从而确定是否需要接收和处理该消息。

2. **过滤器配置**：
   - 在CAN控制器中，可以配置过滤器来接受或拒绝具有特定ID的消息。这有助于减少不必要的数据处理和网络负载。

3. **网络管理**：
   - 通过合理分配CAN ID，可以有效管理网络上的消息流和设备间的通信关系。

#### 总结

CAN ID在CAN总线系统中扮演着至关重要的角色。它不仅用于标识和区分网络上的消息，还决定了消息的优先级和传输顺序。在设计CAN网络和消息时，合理地规划和分配CAN ID是非常重要的，这直接关系到网络的性能和效率。

### CAN ID的使用

在CAN（Controller Area Network）系统中，使用CAN ID正确地发送和接收消息涉及到一系列的配置步骤。以下是使用CAN ID的详细步骤，包括如何发送和接收带有特定ID的消息：

#### 1. 设计CAN网络和消息标识符

首先，你需要为你的CAN网络中的每种消息类型分配一个唯一的CAN ID。这通常根据消息的优先级和功能进行。

#### 2. 配置CAN控制器

在微控制器中，你需要配置CAN控制器以便使用CAN总线。这包括设置波特率、模式（如正常模式或环回模式）和过滤器。

#### 3. 设置CAN消息过滤器

为了接收特定的CAN ID，你需要配置CAN过滤器。这通常包括以下步骤：

- 选择过滤器编号。
- 设置过滤器模式（如标识符掩码模式或标识符列表模式）。
- 设置过滤器比例（如16位或32位）。
- 配置过滤器的ID和掩码。
- 激活过滤器。

#### 4. 发送CAN消息

要发送CAN消息，你需要执行以下步骤：

- 创建一个CAN消息结构体，如`CanTxMsg`。
- 设置消息的标识符（`StdId`或`ExtId`），以及是否是扩展ID（`IDE`）。
- 设置数据长度（`DLC`）和数据本身。
- 调用CAN发送函数，如`CAN_Transmit()`。

#### 5. 接收CAN消息

接收CAN消息通常涉及以下步骤：

- 在中断服务例程中检查新消息。
- 读取接收到的消息。
- 检查消息的标识符，确认它是期望接收的消息。
- 处理消息数据。

#### 6. 错误处理和诊断

配置CAN控制器以监测错误，并在发送或接收过程中处理任何可能发生的错误。

#### 示例代码
假设你要发送一个标准ID为0x123的消息：

```c
CanTxMsg TxMessage;
TxMessage.StdId = 0x123;    // 设置标准标识符
TxMessage.IDE = CAN_Id_Standard; // 使用标准ID
TxMessage.RTR = CAN_RTR_DATA;   // 数据帧
TxMessage.DLC = 2;              // 数据长度为2
TxMessage.Data[0] = 0xAB;       // 数据1
TxMessage.Data[1] = 0xCD;       // 数据2

// 发送消息
CAN_Transmit(CANx, &TxMessage);
```

假设你要配置过滤器以接收ID为0x123的消息：

```c
CAN_FilterInitTypeDef CAN_FilterInitStructure;
CAN_FilterInitStructure.CAN_FilterNumber = 0;
CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;
CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;
CAN_FilterInitStructure.CAN_FilterIdHigh = 0x123 << 5;
CAN_FilterInitStructure.CAN_FilterIdLow = 0x0000;
CAN_FilterInitStructure.CAN_FilterMaskIdHigh = 0xFFFF;
CAN_FilterInitStructure.CAN_FilterMaskIdLow = 0xFFFF;
CAN_FilterInitStructure.CAN_FilterFIFOAssignment = CAN_Filter_FIFO0;
CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
CAN_FilterInit(&CAN_FilterInitStructure);
```

#### 总结

正确地使用CAN ID对于确保CAN通信的有效性和可靠性至关重要。从设计CAN网络的开始，就要考虑如何合理分配和使用CAN ID，这涉及到消息的优先级、过滤器的配置以及消息的发送和接收。通过上述步骤，你可以在CAN系统中有效地使用CAN ID来交换数据。

### 联合体

在C语言中，联合体（Union）是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型，但是不同成员共享这块内存空间。这意味着在同一时间内，联合体只能存储其成员中的一个值。详细来说：

#### 基本概念

1. **共享内存**：
   - 联合体的所有成员都占用相同的内存地址。因此，修改其中一个成员会影响到其他成员。

2. **内存大小**：
   - 联合体的大小等于其最大成员的大小。这是为了确保联合体可以存储其所有可能的值。

3. **成员访问**：
   - 可以像结构体一样访问联合体的成员，但任何时候只有一个成员代表联合体的当前值。

#### 使用场景

1. **节省空间**：
   - 当数据项可能采用多种格式，但不会同时使用时，使用联合体可以节省内存。

2. **类型转换**：
   - 联合体允许以不同的方式访问同一段内存，这在需要对数据进行不同类型的解释时很有用。

3. **硬件接口**：
   - 在硬件编程和嵌入式系统中，联合体常被用于表示具有多种解释的寄存器。

#### 示例

```c
union Data {
    int i;
    float f;
    char str[20];
};

union Data data;
data.i = 10;
data.f = 220.5;
strcpy(data.str, "C Programming");
```

在上面的例子中，`data`是`Data`类型的联合体。当对`data.i`赋值时，`data.f`和`data.str`也在同一内存位置被修改。因此，最后一次赋值（`data.str`）决定了`data`的当前值。

#### 注意事项

- **内存覆盖**：更改一个成员的值会影响联合体的其他成员，因为它们共享内存。
- **类型安全**：由于联合体的这种特性，需要小心使用，避免数据解释错误。

总的来说，联合体是一个强大但需要谨慎使用的工具，特别是在涉及到类型安全和内存管理的地方。正确使用时，它可以在节省内存和提供灵活的数据访问方式方面提供显著的好处。
